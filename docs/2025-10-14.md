# Laboratorium - Funkcje Skr√≥tu (Hashing)

Data: 14 pa≈∫dziernika 2025

## Spis tre≈õci

- [Wstƒôp - Podstawy hashowania](#wstƒôp---podstawy-hashowania)
- [Zadanie 1.1 - Hash MD5](#zadanie-11---hash-md5)
- [Zadanie 1.2 - Hash SHA-256](#zadanie-12---hash-sha-256)
- [Zadanie 1.3 - Hash SHA-512](#zadanie-13---hash-sha-512)
- [Zadanie 1.4 - Hash Argon2i](#zadanie-14---hash-argon2i)
- [Zadanie 1.5 - Hash Bcrypt](#zadanie-15---hash-bcrypt)
- [Zadanie 1.6 - Python: MD5](#zadanie-16---python-md5)
- [Zadanie 1.7 - Python: SHA-1](#zadanie-17---python-sha-1)
- [Zadanie 1.8 - Python: SHA-256](#zadanie-18---python-sha-256)
- [Zadanie 1.9 - Python: Bcrypt](#zadanie-19---python-bcrypt)
- [Zadanie 1.10 i 1.12 - Identyfikacja: SHA-1](#zadanie-110-i-112---identyfikacja-sha-1)
- [Zadanie 1.11 i 1.13 - Identyfikacja: Bcrypt](#zadanie-111-i-113---identyfikacja-bcrypt)
- [Zadanie 1.14 - Identyfikacja: RIPEMD-160](#zadanie-114---identyfikacja-ripemd-160)

---

## Wstƒôp - Podstawy hashowania

### R√≥≈ºnica miƒôdzy `echo` a `echo -n`

```bash
# echo dodaje znak nowej linii (line feed)
echo "marek" | md5sum 
# Output: b0207a607303c08cd4f78c324952d7c2  -

echo "marek" | wc
#       1       1       6

# echo -n NIE dodaje znaku nowej linii
echo -n "marek" | wc
#       0       1       5

echo -n "marek" | md5sum 
# Output: e061c9aea5026301e7b3ff09e9aca2cf  -
```

**Wa≈ºne:** Przy hashowaniu zawsze u≈ºywaj `echo -n` aby uniknƒÖƒá hashowania dodatkowego znaku nowej linii!

### Podstawowe komendy OpenSSL

```bash
# Lista dostƒôpnych algorytm√≥w
openssl dgst -list 

# Przyk≈Çadowe u≈ºycie
echo -n "marek" | openssl dgst -md5 
# Output: MD5(stdin)= e061c9aea5026301e7b3ff09e9aca2cf
```

---

## Zadanie 1.1 - Hash MD5

### Polecenie

Pod adresem `http://127.0.0.1:10001` dzia≈Ça prosty serwer HTTP udostƒôpniajƒÖcy dwa endpointy:
- `http://127.0.0.1:10001/hash` - pobieranie s≈Çowa do zahashowania
- `http://127.0.0.1:10001/submit` - wysy≈Çanie odpowiedzi

**Zadanie:** Oblicz skr√≥t MD5 podanego przez serwer losowego s≈Çowa i wy≈õlij wynik w formacie hex.

### RozwiƒÖzanie

#### (a) Uruchomienie serwera

```bash
docker run -p 10001:10001 docker.io/mazurkatarzyna/hashing-md5-ex1:latest
```

#### (b) Pobranie s≈Çowa i obliczenie hash MD5

```bash
# Pobierz s≈Çowo od serwera
curl -s 127.0.0.1:10001/hash | jq .
```

```json
{
  "session_id": "6224ec9042035711",
  "word": "lostfan"
}
```

```bash
# Oblicz hash MD5
echo -n "lostfan" | openssl dgst -md5 
# Output: MD5(stdin)= b0ef584b7757e61150df570b16f110d5
```

#### (c) Wys≈Çanie odpowiedzi do serwera

```bash
curl -s -X POST 127.0.0.1:10001/submit \
  -H "Content-Type: application/json" \
  -d '{"session_id": "6224ec9042035711", "hash_hex": "b0ef584b7757e61150df570b16f110d5"}' | jq .
```

```json
{
  "result": "Correct MD5 hash!"
}
```

---

## Zadanie 1.2 - Hash SHA-256

### Polecenie

Pod adresem `http://127.0.0.1:10002` dzia≈Ça serwer z endpointami do hashowania SHA-256.

**Zadanie:** Oblicz skr√≥t SHA-256 podanego przez serwer losowego s≈Çowa.

### RozwiƒÖzanie

#### (a) Uruchomienie serwera

```bash
docker run -p 10002:10002 docker.io/mazurkatarzyna/hashing-sha256-ex1:latest
```

#### (b) Pobranie s≈Çowa i obliczenie hash SHA-256

```bash
curl -s 127.0.0.1:10002/hash | jq .
```

```json
{
  "session_id": "f93f2ee9e6637118",
  "word": "dayah1"
}
```

```bash
echo -n "dayah1" | openssl dgst -sha256
# Output: SHA2-256(stdin)= a3c0d2d4464d7d6c1e3bbe362020069194a1dcd2f8f6c9249e0d1c54bde4bae8
```

#### (c) Wys≈Çanie odpowiedzi do serwera

```bash
curl -s -X POST 127.0.0.1:10002/submit \
  -H "Content-Type: application/json" \
  -d '{"session_id": "f93f2ee9e6637118", "hash_hex": "a3c0d2d4464d7d6c1e3bbe362020069194a1dcd2f8f6c9249e0d1c54bde4bae8"}' | jq .
```

```json
{
  "result": "Correct SHA-256 hash!"
}
```

---

## Zadanie 1.3 - Hash SHA-512

### Polecenie

Pod adresem `http://127.0.0.1:10003` dzia≈Ça serwer z endpointami do hashowania SHA-512.

**Zadanie:** Oblicz skr√≥t SHA-512 podanego przez serwer losowego s≈Çowa.

### RozwiƒÖzanie

#### (a) Uruchomienie serwera

```bash
docker run -p 10003:10003 docker.io/mazurkatarzyna/hashing-sha-512-ex1:latest
```

#### (b) Pobranie s≈Çowa i obliczenie hash SHA-512

```bash
curl -s 127.0.0.1:10003/hash | jq .
```

```json
{
  "session_id": "f5f4015412e650ab",
  "word": "loserhead1"
}
```

```bash
echo -n "loserhead1" | openssl dgst -sha512
# Output: SHA2-512(stdin)= bcfabb92d9db9b998688d58d817be2a3c316db24d5b7028414e0ba8a1009657294f9d9d52397e756093dec54437071154cb5c8f51a4d4850d201312258e332be
```

#### (c) Wys≈Çanie odpowiedzi do serwera

```bash
curl -s -X POST 127.0.0.1:10003/submit \
  -H "Content-Type: application/json" \
  -d '{"session_id": "f5f4015412e650ab", "hash_hex": "bcfabb92d9db9b998688d58d817be2a3c316db24d5b7028414e0ba8a1009657294f9d9d52397e756093dec54437071154cb5c8f51a4d4850d201312258e332be"}' | jq .
```

```json
{
  "result": "Correct SHA-512 hash!"
}
```

---

## Zadanie 1.4 - Hash Argon2i

### Polecenie

Pod adresem `http://127.0.0.1:10004` dzia≈Ça serwer z endpointami do hashowania Argon2i.

**Zadanie:** Oblicz skr√≥t Argon2i podanego przez serwer losowego s≈Çowa z okre≈õlonymi parametrami.

### RozwiƒÖzanie

#### (a) Uruchomienie serwera

```bash
docker run -p 10004:10004 docker.io/mazurkatarzyna/hashing-argon-ex1:latest
```

#### (b) Pobranie parametr√≥w i obliczenie hash Argon2i

```bash
curl -s 127.0.0.1:10004/hash | jq .
```

```json
{
  "kdf_options": {
    "iter": 1,
    "keylen": 24,
    "memcost": 8192,
    "salt": "NaCl2024"
  },
  "session_id": "2ca7181d3989a0e8",
  "word": "danish1"
}
```

**KDF (Key Derivation Function)** - funkcja, kt√≥ra generuje klucz poprzez wielokrotne hashowanie z solƒÖ. Spowalnia to proces bruteforce.

```bash
# Uruchom kontener z OpenSSL 3.3.2 (zawiera wsparcie dla Argon2)
docker run -it docker.io/mazurkatarzyna/openssl-332-ubuntu:latest
```

W kontenerze:

```bash
openssl version
# OpenSSL 3.3.2

openssl kdf -keylen 24 -kdfopt pass:danish1 -kdfopt salt:NaCl2024 -kdfopt iter:1 -kdfopt memcost:8192 ARGON2I
# Output: A3:5A:CC:24:AC:08:D6:1B:AA:86:BC:67:16:3B:EC:16:85:D6:79:9E:02:B2:B3:25
```

```bash
# Formatowanie do hex (usuniƒôcie dwukropk√≥w i zamiana na ma≈Çe litery)
echo -n "A3:5A:CC:24:AC:08:D6:1B:AA:86:BC:67:16:3B:EC:16:85:D6:79:9E:02:B2:B3:25" | tr -d ":" | tr '[:upper:]' '[:lower:]'
# Output: a35acc24ac08d61baa86bc67163bec1685d6799e02b2b325
```

#### (c) Wys≈Çanie odpowiedzi do serwera

```bash
curl -s -X POST 127.0.0.1:10004/submit/argon2i \
  -H "Content-Type: application/json" \
  -d '{"session_id": "2ca7181d3989a0e8", "hash_hex": "a35acc24ac08d61baa86bc67163bec1685d6799e02b2b325"}' | jq .
```

```json
{
  "result": "Correct ARGON2I hash!"
}
```

---

## Zadanie 1.5 - Hash Bcrypt

### Polecenie

Pod adresem `http://127.0.0.1:10005` dzia≈Ça serwer z endpointami do hashowania bcrypt.

**Zadanie:** Oblicz skr√≥t bcrypt podanego przez serwer losowego s≈Çowa.

### RozwiƒÖzanie

```bash
# Pobierz s≈Çowo od serwera
curl -s 127.0.0.1:10005/hash | jq .
```

```json
{
  "session_id": "3afab0a889a870f2",
  "word": "niepomilkla"
}
```

```bash
# Wygeneruj hash bcrypt (10 rund)
htpasswd -bnBC 10 user "niepomilkla"
# Output: user:$2y$10$z9LJynbEzdQiV5tqtBSf.OhVv5UKytkrDFJXyVSxWqToxCjz0rjQK
```

```bash
# Wy≈õlij odpowied≈∫
curl -s -X POST 127.0.0.1:10005/submit \
  -H "Content-Type: application/json" \
  -d '{"session_id": "3afab0a889a870f2", "hash_hex": "$2y$10$z9LJynbEzdQiV5tqtBSf.OhVv5UKytkrDFJXyVSxWqToxCjz0rjQK"}' | jq .
```

```json
{
  "result": "Correct bcrypt hash!"
}
```

**üí° Wskaz√≥wka dla bezpiecznych hase≈Ç:** WyRaZ+WyRaZ (np. pierwsze litery z wiersza/piosenki) + znaki specjalne

---

## Zadanie 1.6 - Python: MD5

### Polecenie

Napisz skrypt w jƒôzyku Python, kt√≥ry wygeneruje hash MD5 dowolnego ciƒÖgu znak√≥w podawanego jako argument wywo≈Çania skryptu. Sprawd≈∫ poprawno≈õƒá por√≥wnujƒÖc z `md5sum` lub `openssl`. Wykorzystaj bibliotekƒô `hashlib`.

### RozwiƒÖzanie

**Plik:** `zadanie_1_6.py`

```python
#!/usr/bin/env python3
"""
Zadanie 1.6: Generowanie hash MD5 z wykorzystaniem hashlib
"""

import hashlib
import sys


def md5_hash_string(input_string: str) -> str:
    """
    Returns the MD5 hash of a given string.
    """
    # Konwertuj string na bajty
    input_bytes = input_string.encode("utf-8")
    # Stw√≥rz obiekt MD5 hash
    md5_hash = hashlib.md5(input_bytes)
    # Zwr√≥ƒá hash w formacie hex
    return md5_hash.hexdigest()


if __name__ == "__main__":
    if len(sys.argv) > 1:
        text = sys.argv[1]
    else:
        text = "hello world"

    result = md5_hash_string(text)
    print(f"MD5 hash of '{text}': {result}")
```

### Testowanie

```bash
# Uruchom skrypt
python3 zadanie_1_6.py "hello world"
# Output: MD5 hash of 'hello world': 5eb63bbbe01eeed093cb22bb8f5acdc3

# Weryfikacja z md5sum
echo -n "hello world" | md5sum
# Output: 5eb63bbbe01eeed093cb22bb8f5acdc3  -

# ‚úì Hashe siƒô zgadzajƒÖ!
```

---

## Zadanie 1.7 - Python: SHA-1

### Polecenie

Napisz skrypt w jƒôzyku Python, kt√≥ry wygeneruje hash SHA-1 dowolnego ciƒÖgu znak√≥w podawanego jako argument wywo≈Çania skryptu. Sprawd≈∫ poprawno≈õƒá por√≥wnujƒÖc z `sha1sum` lub `openssl`. Wykorzystaj bibliotekƒô `hashlib`.

### RozwiƒÖzanie

**Plik:** `zadanie_1_7.py`

```python
#!/usr/bin/env python3
"""
Zadanie 1.7: Generowanie hash SHA-1 z wykorzystaniem hashlib
"""

import hashlib
import sys


def sha1_hash_string(input_string: str) -> str:
    """
    Returns the SHA-1 hash of a given string.
    """
    # Konwertuj string na bajty
    input_bytes = input_string.encode("utf-8")
    # Stw√≥rz obiekt SHA-1 hash
    sha1_hash = hashlib.sha1(input_bytes)
    # Zwr√≥ƒá hash w formacie hex
    return sha1_hash.hexdigest()


if __name__ == "__main__":
    if len(sys.argv) > 1:
        text = sys.argv[1]
    else:
        text = "hello world"

    result = sha1_hash_string(text)
    print(f"SHA-1 hash of '{text}': {result}")
```

### Testowanie

```bash
# Uruchom skrypt
python3 zadanie_1_7.py "hello world"
# Output: SHA-1 hash of 'hello world': 2aae6c35c94fcfb415dbe95f408b9ce91ee846ed

# Weryfikacja z sha1sum
echo -n "hello world" | sha1sum
# Output: 2aae6c35c94fcfb415dbe95f408b9ce91ee846ed  -

# ‚úì Hashe siƒô zgadzajƒÖ!
```

---

## Zadanie 1.8 - Python: SHA-256

### Polecenie

Napisz skrypt w jƒôzyku Python, kt√≥ry wygeneruje hash SHA-256 dowolnego ciƒÖgu znak√≥w podawanego jako argument wywo≈Çania skryptu. Sprawd≈∫ poprawno≈õƒá por√≥wnujƒÖc z `openssl`. Wykorzystaj bibliotekƒô `hashlib`.

### RozwiƒÖzanie

**Plik:** `zadanie_1_8.py`

```python
#!/usr/bin/env python3
"""
Zadanie 1.8: Generowanie hash SHA-256 z wykorzystaniem hashlib
"""

import hashlib
import sys


def sha256_hash_string(input_string: str) -> str:
    """
    Returns the SHA-256 hash of a given string.
    """
    # Konwertuj string na bajty
    input_bytes = input_string.encode("utf-8")
    # Stw√≥rz obiekt SHA-256 hash
    sha256_hash = hashlib.sha256(input_bytes)
    # Zwr√≥ƒá hash w formacie hex
    return sha256_hash.hexdigest()


if __name__ == "__main__":
    if len(sys.argv) > 1:
        text = sys.argv[1]
    else:
        text = "hello world"

    result = sha256_hash_string(text)
    print(f"SHA-256 hash of '{text}': {result}")
```

### Testowanie

```bash
# Uruchom skrypt
python3 zadanie_1_8.py "hello world"
# Output: SHA-256 hash of 'hello world': b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9

# Weryfikacja z openssl
echo -n "hello world" | openssl dgst -sha256
# Output: SHA2-256(stdin)= b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9

# ‚úì Hashe siƒô zgadzajƒÖ!
```

---

## Zadanie 1.9 - Python: Bcrypt

### Polecenie

Napisz skrypt w jƒôzyku Python, kt√≥ry wygeneruje hash bcrypt dowolnego ciƒÖgu znak√≥w podawanego jako argument wywo≈Çania skryptu. Sprawd≈∫ poprawno≈õƒá por√≥wnujƒÖc z `htpasswd`. Wykorzystaj bibliotekƒô `bcrypt`.

### RozwiƒÖzanie

**Instalacja biblioteki:**

```bash
pip install bcrypt
```

**Plik:** `zadanie_1_9.py`

```python
#!/usr/bin/env python3
"""
Zadanie 1.9: Generowanie hash bcrypt z wykorzystaniem biblioteki bcrypt
Instalacja: pip install bcrypt
"""

import sys
import bcrypt


def bcrypt_hash_password(password: str) -> str:
    """
    Hash a password using bcrypt.
    """
    # Konwertuj has≈Ço na bajty
    password_bytes = password.encode("utf-8")
    # Wygeneruj salt i hash has≈Ça (10 rund)
    salt = bcrypt.gensalt(rounds=10)
    hashed = bcrypt.hashpw(password_bytes, salt)
    # Zwr√≥ƒá hash jako string
    return hashed.decode("utf-8")


def bcrypt_verify_password(password: str, hashed: str) -> bool:
    """
    Verify a password against a bcrypt hash.
    """
    # Konwertuj has≈Ço i hash na bajty
    password_bytes = password.encode("utf-8")
    hashed_bytes = hashed.encode("utf-8")
    # Zweryfikuj has≈Ço
    return bcrypt.checkpw(password_bytes, hashed_bytes)


# Example usage
if __name__ == "__main__":
    if len(sys.argv) > 1:
        pwd = sys.argv[1]
    else:
        pwd = "my_secure_password"

    # Hash the password
    hashed_pwd = bcrypt_hash_password(pwd)
    print(f"Password: {pwd}")
    print(f"Bcrypt hash: {hashed_pwd}")

    # Verify the password
    is_valid = bcrypt_verify_password(pwd, hashed_pwd)
    print(f"Verification: {is_valid}")

    # Test with wrong password
    is_valid_wrong = bcrypt_verify_password("wrong_password", hashed_pwd)
    print(f"Verification with wrong password: {is_valid_wrong}")
```

### Testowanie

```bash
# Uruchom skrypt
python3 zadanie_1_9.py "my_secure_password"
```

```
Password: my_secure_password
Bcrypt hash: $2b$10$cCQSEjG1SLXoffSK7VckzOTJGh4Pi1SH8x4cGDXcZbTQgukJzTWzO
Verification: True
Verification with wrong password: False
```

**Weryfikacja z htpasswd:**

```bash
htpasswd -bnBC 10 user "my_secure_password"
# Output: user:$2y$10$...hash...

# Ka≈ºde uruchomienie generuje inny hash (inny salt), ale wszystkie sƒÖ poprawne!
```

---

## Zadanie 1.10 i 1.12 - Identyfikacja: SHA-1

### Polecenie

MajƒÖc dany poczƒÖtkowy ciƒÖg znak√≥w `helloworld`, kt√≥ry nastƒôpnie zosta≈Ç zahashowany, okre≈õl, jaka funkcja skr√≥tu zosta≈Ça wykorzystana do utworzenia hasha: `6adfb183a4a2c94a2f92dab5ade762a47889a5a1`.

**Uwaga:** Mo≈ºna u≈ºyƒá narzƒôdzia `hash-identifier` lub `hashid`, ale mo≈ºemy r√≥wnie≈º napisaƒá w≈Çasne rozwiƒÖzanie w Python.

### RozwiƒÖzanie

**Plik:** `zadanie_1_10_13.py`

```python
#!/usr/bin/env python3
"""
Zadania 1.10-1.13: Identyfikacja typ√≥w hash√≥w
Zamiast u≈ºywaƒá hash-identifier lub hashid, testujemy r√≥≈ºne algorytmy
"""

import hashlib


def identify_hash(original_text: str, target_hash: str):
    """
    Pr√≥buje zidentyfikowaƒá algorytm hash poprzez testowanie popularnych algorytm√≥w
    """
    input_bytes = original_text.encode("utf-8")

    # Lista popularnych algorytm√≥w hash z ich typowƒÖ d≈Çugo≈õciƒÖ
    common_algorithms = {
        "md5": 32,
        "sha1": 40,
        "sha224": 56,
        "sha256": 64,
        "sha384": 96,
        "sha512": 128,
        "sha3_224": 56,
        "sha3_256": 64,
        "sha3_384": 96,
        "sha3_512": 128,
    }

    print(f"Tekst oryginalny: '{original_text}'")
    print(f"Hash do zidentyfikowania: {target_hash}")
    print(f"D≈Çugo≈õƒá hash: {len(target_hash)} znak√≥w")

    # Sprawd≈∫ czy to bcrypt (zaczyna siƒô od $2y$ lub $2a$ lub $2b$)
    if (
        target_hash.startswith("$2y$")
        or target_hash.startswith("$2a$")
        or target_hash.startswith("$2b$")
    ):
        print("\n‚úì Zidentyfikowano: BCRYPT")
        print("  Format: $2y$rounds$salt+hash")
        return "bcrypt"

    print("\nTestowanie standardowych algorytm√≥w hash:")
    print("-" * 60)

    found = False
    for algo_name, expected_len in common_algorithms.items():
        try:
            h = hashlib.new(algo_name, input_bytes)
            result = h.hexdigest()

            match = "‚úì MATCH!" if result.lower() == target_hash.lower() else ""
            print(f"{algo_name:12} ({expected_len} znak√≥w): {result[:20]}... {match}")

            if result.lower() == target_hash.lower():
                found = True
                print(f"\n‚úì ZNALEZIONO! Algorytm: {algo_name.upper()}")
        except Exception:
            pass

    if not found:
        print("\nNie znaleziono pasujƒÖcego algorytmu w≈õr√≥d standardowych hash√≥w.")

    return None


if __name__ == "__main__":
    print("=" * 60)
    print("ZADANIE 1.10 i 1.12")
    print("=" * 60)
    identify_hash("helloworld", "6adfb183a4a2c94a2f92dab5ade762a47889a5a1")
```

### Wynik

```bash
python3 zadanie_1_10_13.py
```

```
============================================================
ZADANIE 1.10 i 1.12
============================================================
Tekst oryginalny: 'helloworld'
Hash do zidentyfikowania: 6adfb183a4a2c94a2f92dab5ade762a47889a5a1
D≈Çugo≈õƒá hash: 40 znak√≥w

Testowanie standardowych algorytm√≥w hash:
------------------------------------------------------------
md5          (32 znak√≥w): fc5e038d38a570320854... 
sha1         (40 znak√≥w): 6adfb183a4a2c94a2f92... ‚úì MATCH!

‚úì ZNALEZIONO! Algorytm: SHA1
```

**Odpowied≈∫:** Hash zosta≈Ç wygenerowany algorytmem **SHA-1**

---

## Zadanie 1.11 i 1.13 - Identyfikacja: Bcrypt

### Polecenie

MajƒÖc dany poczƒÖtkowy ciƒÖg znak√≥w `helloworld`, kt√≥ry nastƒôpnie zosta≈Ç zahashowany, okre≈õl, jaka funkcja skr√≥tu zosta≈Ça wykorzystana do utworzenia hasha: `$2y$10$xbyAv5a46CQYPay5UISCNeFWpVdx2qvhCBEOZ/YtfxoVXhOGrVKQa`.

### RozwiƒÖzanie

U≈ºywamy tego samego skryptu co w zadaniu 1.10, ale modyfikujemy `__main__`:

```python
if __name__ == "__main__":
    print("=" * 60)
    print("ZADANIE 1.11 i 1.13")
    print("=" * 60)
    identify_hash("helloworld", "$2y$10$xbyAv5a46CQYPay5UISCNeFWpVdx2qvhCBEOZ/YtfxoVXhOGrVKQa")
```

### Wynik

```
============================================================
ZADANIE 1.11 i 1.13
============================================================
Tekst oryginalny: 'helloworld'
Hash do zidentyfikowania: $2y$10$xbyAv5a46CQYPay5UISCNeFWpVdx2qvhCBEOZ/YtfxoVXhOGrVKQa
D≈Çugo≈õƒá hash: 60 znak√≥w

‚úì Zidentyfikowano: BCRYPT
  Format: $2y$rounds$salt+hash
```

**Odpowied≈∫:** Hash zosta≈Ç wygenerowany algorytmem **Bcrypt**

**Wyja≈õnienie formatu:**
- `$2y$` - oznacza bcrypt
- `10` - liczba rund (2^10 = 1024 iteracje)
- Nastƒôpnie salt i hash

---

## Zadanie 1.14 - Identyfikacja: RIPEMD-160

### Polecenie

MajƒÖc dany poczƒÖtkowy ciƒÖg znak√≥w `R3iSrSNmgU9SFHxVekUD`, kt√≥ry nastƒôpnie zosta≈Ç zahashowany, okre≈õl, jaka funkcja skr√≥tu zosta≈Ça wykorzystana do utworzenia hasha: `48cab4b54bef42fddaa6353c68a20b369f40026e`.

**Podpowied≈∫:** Algorytm jest dostƒôpny w bibliotece `hashlib`.

### RozwiƒÖzanie

**Plik:** `zadanie_1_14.py`

```python
#!/usr/bin/env python3
"""
Zadanie 1.14: Identyfikacja funkcji skr√≥tu dla hashu 48cab4b54bef42fddaa6353c68a20b369f40026e
Tekst oryginalny: R3iSrSNmgU9SFHxVekUD
"""

import hashlib


def test_all_hashes(input_string: str, target_hash: str):
    """
    Testuje wszystkie dostƒôpne algorytmy hash z hashlib
    """
    input_bytes = input_string.encode("utf-8")

    # Lista algorytm√≥w dostƒôpnych w hashlib
    algorithms = hashlib.algorithms_available

    print(f"Szukam algorytmu dla: '{input_string}'")
    print(f"Oczekiwany hash: {target_hash}")
    print(f"\nTestowanie {len(algorithms)} algorytm√≥w...\n")

    found = False
    for algo_name in sorted(algorithms):
        try:
            # Stw√≥rz hash dla danego algorytmu
            h = hashlib.new(algo_name, input_bytes)
            result = h.hexdigest()

            # Sprawd≈∫ czy hash siƒô zgadza
            if result.lower() == target_hash.lower():
                print(f"‚úì ZNALEZIONO! Algorytm: {algo_name}")
                print(f"  Hash: {result}")
                found = True
        except Exception:
            # Niekt√≥re algorytmy mogƒÖ wymagaƒá dodatkowych parametr√≥w
            pass

    if not found:
        print("Nie znaleziono pasujƒÖcego algorytmu.")
        print("\nPr√≥ba najpopularniejszych algorytm√≥w:")
        for algo in ["md5", "sha1", "sha224", "sha256", "sha384", "sha512"]:
            h = hashlib.new(algo, input_bytes)
            print(f"  {algo}: {h.hexdigest()}")


if __name__ == "__main__":
    original_text = "R3iSrSNmgU9SFHxVekUD"
    target_hash = "48cab4b54bef42fddaa6353c68a20b369f40026e"

    test_all_hashes(original_text, target_hash)
```

### Wynik

```bash
python3 zadanie_1_14.py
```

```
Szukam algorytmu dla: 'R3iSrSNmgU9SFHxVekUD'
Oczekiwany hash: 48cab4b54bef42fddaa6353c68a20b369f40026e

Testowanie 19 algorytm√≥w...

‚úì ZNALEZIONO! Algorytm: ripemd160
  Hash: 48cab4b54bef42fddaa6353c68a20b369f40026e
```

**Odpowied≈∫:** Hash zosta≈Ç wygenerowany algorytmem **RIPEMD-160**

**RIPEMD-160** (RACE Integrity Primitives Evaluation Message Digest):
- Generuje hash 160-bitowy (40 znak√≥w hex)
- Podobna d≈Çugo≈õƒá jak SHA-1, ale inny algorytm
- U≈ºywany m.in. w Bitcoin

---

## Podsumowanie

### Formaty hash√≥w

| Algorytm | D≈Çugo≈õƒá hex | D≈Çugo≈õƒá bitowa | Przyk≈Çad |
|----------|-------------|----------------|----------|
| MD5 | 32 znaki | 128 bit√≥w | `5eb63bbbe01eeed093cb22bb8f5acdc3` |
| SHA-1 | 40 znak√≥w | 160 bit√≥w | `2aae6c35c94fcfb415dbe95f408b9ce91ee846ed` |
| RIPEMD-160 | 40 znak√≥w | 160 bit√≥w | `48cab4b54bef42fddaa6353c68a20b369f40026e` |
| SHA-256 | 64 znaki | 256 bit√≥w | `b94d27b9934d3e08a52e52d7da7dab...` |
| SHA-512 | 128 znak√≥w | 512 bit√≥w | `bcfabb92d9db9b998688d58d817be2...` |
| Bcrypt | 60 znak√≥w | - | `$2y$10$xbyAv5a46CQYPay5UISCNe...` |

### Weryfikacja hash√≥w w konsoli

```bash
# MD5
echo -n "tekst" | md5sum
echo -n "tekst" | openssl dgst -md5

# SHA-1
echo -n "tekst" | sha1sum
echo -n "tekst" | openssl dgst -sha1

# SHA-256
echo -n "tekst" | sha256sum
echo -n "tekst" | openssl dgst -sha256

# SHA-512
echo -n "tekst" | sha512sum
echo -n "tekst" | openssl dgst -sha512

# Bcrypt (wymaga htpasswd z apache2-utils)
htpasswd -bnBC 10 user "haslo"
```

### Biblioteki Python

- **hashlib** - standardowa biblioteka (MD5, SHA-1, SHA-256, SHA-512, RIPEMD-160, SHA-3)
- **bcrypt** - zewnƒôtrzna biblioteka (instalacja: `pip install bcrypt`)

### Skrypty

Wszystkie skrypty Python znajdujƒÖ siƒô w tym katalogu:

- `zadanie_1_6.py` - Generator MD5
- `zadanie_1_7.py` - Generator SHA-1
- `zadanie_1_8.py` - Generator SHA-256
- `zadanie_1_9.py` - Generator Bcrypt
- `zadanie_1_10_13.py` - Identyfikator hash√≥w (SHA-1, Bcrypt)
- `zadanie_1_14.py` - Identyfikator hash√≥w (wszystkie algorytmy)

---

**Autor:** Notatki z laboratorium bezpiecze≈Ñstwa  
**Data:** 14 pa≈∫dziernika 2025
