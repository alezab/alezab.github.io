# GPG Exercises - 2025-11-18

## Exercise 5.1

Pod adresem http://127.0.0.1:5001 dzia≈Ça prosty serwer HTTP udostƒôpniajƒÖcy 2 endpointy: http://127.0.0.1:5001/submit/public oraz http://127.0.0.1:5001/submit/private.

**(a)** Uruchom serwer za pomocƒÖ poni≈ºszego polecenia:

```bash
docker run -p 5001:5001 --name ex1 docker.io/mazurkatarzyna/gpg-ex1:latest
```

**(b)** Wygeneruj parƒô kluczy GPG u≈ºywajƒÖc algorytmu RSA.

```bash
gpg --list-keys
gpg --full-generate-key
# 1
# 2048
# 6m
# y 
# Jan Kowalski
# jan_kowalski@abc.pl
# Klucz testowy
# Ok 
# Password: Anakonda
```

Output:
```
pub   rsa2048 2025-11-18 [SC] [expires: 2025-11-25]
      C3D85E29FA195F3379CBC9568C8DB94F59FD5FA4
uid                      Jan Kowalski (Klucz testowy) <jan_kowalski@abc.pl>
sub   rsa2048 2025-11-18 [E] [expires: 2025-11-25]
```

**(c)** Wyeksportuj klucz publiczny i klucz prywatny do plik√≥w, odpowiednio pub.key oraz priv.key.

```bash
gpg --export --armor C3D85E29FA195F3379CBC9568C8DB94F59FD5FA4 > pub.key
gpg --export-secret-keys --armor C3D85E29FA195F3379CBC9568C8DB94F59FD5FA4 > priv.key
```

**(d)** Wy≈õlij request do endpointa http://127.0.0.1:5001/submit/public u≈ºywajƒÖc metody HTTP POST i prze≈õlij na serwer wyeksportowany klucz publiczny GPG. Serwer w odpowiedzi zwr√≥ci informacje o kluczu.

```bash
curl -s 127.0.0.1:5001/submit/public -F "file=@pub.key" | jq .
```

Output:
```json
{
  "algo": "1",
  "created": "1763463084",
  "expires": "1764067884",
  "fingerprint": "C3D85E29FA195F3379CBC9568C8DB94F59FD5FA4",
  "key_id": "8C8DB94F59FD5FA4",
  "length": "2048",
  "trust": "-",
  "type": "public",
  "uids": [
    "Jan Kowalski (Klucz testowy) <jan_kowalski@abc.pl>"
  ]
}
```

**(e)** Wy≈õlij request do endpointa http://127.0.0.1:5001/submit/private u≈ºywajƒÖc metody HTTP POST i prze≈õlij na serwer wyeksportowany klucz prywatny GPG. Serwer w odpowiedzi zwr√≥ci informacje o kluczu.

```bash
curl -s 127.0.0.1:5001/submit/private -F "file=@priv.key" | jq .
```

Output:
```json
{
  "algo": "1",
  "created": "1763463084",
  "expires": "1764067884",
  "fingerprint": "C3D85E29FA195F3379CBC9568C8DB94F59FD5FA4",
  "key_id": "8C8DB94F59FD5FA4",
  "length": "2048",
  "trust": "-",
  "type": "private",
  "uids": [
    "Jan Kowalski (Klucz testowy) <jan_kowalski@abc.pl>"
  ]
}
```

**UWAGI:**
- Aby za pomocƒÖ narzƒôdzia cURL wys≈Çaƒá plik do serwera, u≈ºyj sk≈Çadni: `-F "plik=@hello.txt"`

---

## Exercise 5.2

Pod adresem http://127.0.0.1:5002 dzia≈Ça prosty serwer HTTP udostƒôpniajƒÖcy 2 endpointy: http://127.0.0.1:5002/submit/public oraz http://127.0.0.1:5002/submit/private.

**(a)** Uruchom serwer za pomocƒÖ poni≈ºszego polecenia:

```bash
docker rm -f ex2
docker run -p 5002:5002 --name ex2 docker.io/mazurkatarzyna/gpg-ex2:latest
```

**(b)** Wygeneruj parƒô kluczy GPG u≈ºywajƒÖc algorytmu DSA.

```bash
gpg --quick-generate-key "Jan Kowalski DSA <jan_dsa@abc.pl>" dsa2048 sign,auth 6m
```

Output:
```
pub   dsa2048 2025-11-30 [SCA] [expires: 2026-05-29]
      61F45CD449005B4981BE7B93918B4BAB57BF4D5B
uid                      Jan Kowalski DSA <jan_dsa@abc.pl>
```

**(c)** Wyeksportuj klucz publiczny i klucz prywatny do plik√≥w, odpowiednio pub.key oraz priv.key.

```bash
gpg --export --armor 61F45CD449005B4981BE7B93918B4BAB57BF4D5B > pub.key
gpg --export-secret-keys --armor 61F45CD449005B4981BE7B93918B4BAB57BF4D5B > priv.key
```

**(d)** Wy≈õlij request do endpointa http://127.0.0.1:5002/submit/public u≈ºywajƒÖc metody HTTP POST i prze≈õlij na serwer wyeksportowany klucz publiczny GPG. Serwer w odpowiedzi zwr√≥ci informacje o kluczu.

```bash
curl -s 127.0.0.1:5002/submit/public -F "file=@pub.key" | jq .
```

Output:
```json
{
  "algorithm": "DSA",
  "created": "1764536071",
  "expires": "1780088071",
  "fingerprint": "61F45CD449005B4981BE7B93918B4BAB57BF4D5B",
  "format": "GPG/OpenPGP",
  "key_id": "918B4BAB57BF4D5B",
  "key_size": 2048,
  "trust": "-",
  "type": "public",
  "uids": [
    "Jan Kowalski DSA <jan_dsa@abc.pl>"
  ]
}
```

**(e)** Wy≈õlij request do endpointa http://127.0.0.1:5002/submit/private u≈ºywajƒÖc metody HTTP POST i prze≈õlij na serwer wyeksportowany klucz prywatny GPG. Serwer w odpowiedzi zwr√≥ci informacje o kluczu.

```bash
curl -s 127.0.0.1:5002/submit/private -F "file=@priv.key" | jq .
```

Output:
```json
{
  "algorithm": "DSA",
  "created": "1764536071",
  "expires": "1780088071",
  "fingerprint": "61F45CD449005B4981BE7B93918B4BAB57BF4D5B",
  "format": "GPG/OpenPGP",
  "key_id": "918B4BAB57BF4D5B",
  "key_size": 2048,
  "trust": "-",
  "type": "private",
  "uids": [
    "Jan Kowalski DSA <jan_dsa@abc.pl>"
  ]
}
```

**UWAGI:**
- Aby za pomocƒÖ narzƒôdzia cURL wys≈Çaƒá plik do serwera, u≈ºyj sk≈Çadni: `-F "plik=@hello.txt"`

---

## Exercise 5.3

Pod adresem http://127.0.0.1:5003 dzia≈Ça prosty serwer HTTP udostƒôpniajƒÖcy 2 endpointy: http://127.0.0.1:5003/submit/public oraz http://127.0.0.1:5003/submit/private.

**(a)** Uruchom serwer za pomocƒÖ poni≈ºszego polecenia:

```bash
docker rm -f ex3
docker run -p 5003:5003 --name ex3 docker.io/mazurkatarzyna/gpg-ex3:latest
```

**(b)** Wygeneruj parƒô kluczy GPG u≈ºywajƒÖc algorytmu RSA. Klucze powinny mieƒá 1024 bity d≈Çugo≈õci, majƒÖ byƒá wa≈ºne rok, oraz byƒá wygenerowane dla adresu student@uczelnia.pl.

```bash
gpg --quick-generate-key "Student <student@uczelnia.pl>" rsa1024 sign,auth 1y
```

Output:
```
pub   rsa1024 2025-11-30 [SCA] [expires: 2026-11-30]
      4177BD07C3B6D5902BF6977CFCDFDE711931002F
uid                      Student <student@uczelnia.pl>
```

**(c)** Wyeksportuj klucz publiczny i klucz prywatny do plik√≥w, odpowiednio pub.key oraz priv.key.

```bash
gpg --export --armor 4177BD07C3B6D5902BF6977CFCDFDE711931002F > pub.key
gpg --export-secret-keys --armor 4177BD07C3B6D5902BF6977CFCDFDE711931002F > priv.key
```

**(d)** Wy≈õlij request do endpointa http://127.0.0.1:5003/submit/public u≈ºywajƒÖc metody HTTP POST i prze≈õlij na serwer wyeksportowany klucz publiczny GPG. Serwer w odpowiedzi zwr√≥ci informacje o kluczu.

```bash
curl -s 127.0.0.1:5003/submit/public -F "file=@pub.key" | jq .
```

Output:
```json
{
  "algo": "1",
  "created": "1764536205",
  "expires": "1796072205",
  "fingerprint": "4177BD07C3B6D5902BF6977CFCDFDE711931002F",
  "key_id": "FCDFDE711931002F",
  "length": "1024",
  "trust": "-",
  "type": "public",
  "uids": [
    "Student <student@uczelnia.pl>"
  ],
  "validation": "passed"
}
```

**(e)** Wy≈õlij request do endpointa http://127.0.0.1:5003/submit/private u≈ºywajƒÖc metody HTTP POST i prze≈õlij na serwer wyeksportowany klucz prywatny GPG. Serwer w odpowiedzi zwr√≥ci informacje o kluczu.

```bash
curl -s 127.0.0.1:5003/submit/private -F "file=@priv.key" | jq .
```

Output:
```json
{
  "algo": "1",
  "created": "1764536205",
  "expires": "1796072205",
  "fingerprint": "4177BD07C3B6D5902BF6977CFCDFDE711931002F",
  "key_id": "FCDFDE711931002F",
  "length": "1024",
  "trust": "-",
  "type": "private",
  "uids": [
    "Student <student@uczelnia.pl>"
  ],
  "validation": "passed"
}
```

---

## Exercise 5.4

Pod adresem http://127.0.0.1:5004 dzia≈Ça prosty serwer HTTP udostƒôpniajƒÖcy 2 endpointy: http://127.0.0.1:5004/decrypt oraz http://127.0.0.1:5004/submit.

**(a)** Uruchom serwer za pomocƒÖ poni≈ºszego polecenia:

```bash
docker run -p 5004:5004 --name ex4 docker.io/mazurkatarzyna/gpg-ex4:latest
```

**(b)** Wy≈õlij request do endpointa http://127.0.0.1:5004/decrypt u≈ºywajƒÖc metody HTTP GET i zapisz odpowied≈∫ do pliku z rozszerzeniem *.zip.

```bash
curl -s 127.0.0.1:5004/decrypt -o data.zip
```

**(c)** Rozpakuj pobrane archiwum.

```bash
unzip data.zip
```

Output:
```
Archive:  data.zip
  inflating: encrypted.txt           
  inflating: passphrase.txt          
  inflating: session_id.txt
```

**(d)** Odszyfruj plik encrypted.txt u≈ºywajƒÖc algorytmu CAMELLIA128 i has≈Ça znajdujƒÖcego siƒô w pliku passphrase.txt.

```bash
gpg --decrypt encrypted.txt
# gpg: CAMELLIA128.CFB encrypted data
# dragon
# gpg: encrypted with 1 passphrase
# password
```

**(e)** Wy≈õlij request do endpointa http://127.0.0.1:5004/submit/ u≈ºywajƒÖc metody HTTP POST, i prze≈õlij do serwera ID sesji (jako session_id, kt√≥re znajdziesz w pliku session_id.txt) oraz odszyfrowane s≈Çowo (jako decrypted_text). Serwer w odpowiedzi zwr√≥ci informacje o poprawnym lub nieprawid≈Çowym deszyfrowaniu.

```bash
curl -s -X POST http://127.0.0.1:5004/submit \
  -H "Content-Type: application/json" \
  -d '{"decrypted_text": "password", "session_id": "0058f11c050df0c124ef4a71a35a43a9"}' | jq .
```

**UWAGI:**
- Aby zapisaƒá odpowied≈∫ do pliku z rozszerzeniem *.zip, u≈ºyj opcji `-o`.
- Podczas deszyfrowania symetrycznego sprawd≈∫ opcje: `--cipher-algo`, `--batch --yes`, `--passphrase`

---

## Exercise 5.5

Pod adresem http://127.0.0.1:5005 dzia≈Ça prosty serwer HTTP udostƒôpniajƒÖcy 2 endpointy: http://127.0.0.1:5005/encrypt oraz http://127.0.0.1:5005/submit.

**(a)** Uruchom serwer za pomocƒÖ poni≈ºszego polecenia:

```bash
docker rm -f ex5
docker run -p 5005:5005 --name ex5 docker.io/mazurkatarzyna/gpg-ex5:latest
```

**(b)** Wy≈õlij request do endpointa http://127.0.0.1:5005/encrypt u≈ºywajƒÖc metody HTTP GET. W odpowiedzi od serwera otrzymasz s≈Çowo do zaszyfrowania (jako word_to_encrypt), has≈Ço potrzebne do szyfrowania (jako passphrase) oraz id sesji (jako session_id).

```bash
curl -s 127.0.0.1:5005/encrypt | jq .
```

Output:
```json
{
  "session_id": "1c35d34017eb501e464e6347898a5dd9",
  "word_to_encrypt": "asm",
  "passphrase": "creation",
  "algorithm": "AES128"
}
```

**(c)** Zaszyfruj odebrane od serwera s≈Çowo (word_to_encrypt) za pomocƒÖ algorytmu AES128 oraz odebranego od serwera has≈Ça (passphrase). Zaszyfrowane s≈Çowo ma byƒá r√≥wnie≈º zakodowane przy pomocy kodowania base64.

```bash
echo -n "asm" | gpg --symmetric --cipher-algo AES128 --passphrase "creation" --batch --yes --armor -o encrypted.asc
```

**(d)** Wy≈õlij request do endpointa http://127.0.0.1:5005/submit u≈ºywajƒÖc metody HTTP POST i prze≈õlij do serwera id sesji (jako session_id) oraz zaszyfrowany i zakodowany plik (jako plik, encrypted_file).

```bash
curl -s 127.0.0.1:5005/submit -F "session_id=1c35d34017eb501e464e6347898a5dd9" -F "encrypted_file=@encrypted.asc" | jq .
```

Output:
```json
{
  "status": "success",
  "message": "Gratulacje! Poprawnie zaszyfrowa≈Çe≈õ plik!",
  "word": "asm",
  "passphrase_used": "creation"
}
```

**UWAGI:**
- Aby wykorzystaƒá kodowanie base64 podczas szyfrowania, u≈ºyj opcji `--armor`
- Aby za pomocƒÖ narzƒôdzia cURL wys≈Çaƒá plik do serwera, u≈ºyj sk≈Çadni: `-F "plik=@hello.txt"`

---

## Exercise 5.6

Pod adresem http://127.0.0.1:5006 dzia≈Ça prosty serwer HTTP udostƒôpniajƒÖcy 2 endpointy: http://127.0.0.1:5006/encrypt oraz http://127.0.0.1:5006/submit.

**(a)** Uruchom serwer za pomocƒÖ poni≈ºszego polecenia:

```bash
docker run -p 5006:5006 --name ex6 docker.io/mazurkatarzyna/gpg-ex6:latest
```

**(b)** Wy≈õlij request do endpointa http://127.0.0.1:5005/encrypt u≈ºywajƒÖc metody HTTP GET i zapisz odpowied≈∫ do pliku z rozszerzeniem *.zip.

```bash
curl -s 127.0.0.1:5006/encrypt -o data.zip
```

**(c)** Rozpakuj pobrane archiwum. W odpowiedzi od serwera otrzyma≈Çe≈õ id sesji (jako session_id), klucz publiczny GPG (public_key.asc), klucz prywatny GPG (private_key.asc), oraz s≈Çowo do zaszyfrowania (word.txt).

```bash
unzip data.zip
```

**(d)** Zaimportuj do swojego zbioru kluczy klucz publiczny pobrany od serwera.

```bash
gpg --import public_key.asc
```

Output:
```
gpg: key A43D788DC5E9439A: public key "Challenge User <challengex6@example.com>" imported
gpg: Total number processed: 1
gpg:               imported: 1
```

**(e)** WykorzystujƒÖc narzƒôdzie gpg oraz pobrany klucz publiczny (z pliku public_key.asc), zaszyfruj odebrane od serwera s≈Çowo (podczas szyfrowania nie u≈ºywaj has≈Ça).

```bash
gpg --list-keys
# pub   rsa2048 2025-11-18 [SCEAR]
#       844AEAF70484113D1A8AD3B5A43D788DC5E9439A
# uid           [ unknown] Challenge User <challengex6@example.com>

gpg --encrypt --armor -r challengex6@example.com word.txt
# y
```

**(f)** Zaszyfrowane s≈Çowo zakoduj w base64 i zapisz do pliku.

```bash
cat word.txt.asc
```

**(g)** Wy≈õlij request do endpointa http://127.0.0.1:5006/submit u≈ºywajƒÖc metody HTTP POST i prze≈õlij do serwera id sesji (jako session_id) oraz zaszyfrowane i zakodowane s≈Çowo (jako plik, encrypted_file).

```bash
curl -s 127.0.0.1:5006/submit -F "session_id=$(cat session_id.txt)" -F "encrypted_file=@word.txt.asc" | jq .
```

Output:
```json
{
  "status": "success",
  "message": "Gratulacje! Poprawnie zaszyfrowa≈Çe≈õ plik!",
  "word": "ursula"
}
```

**UWAGI:**
- Aby zapisaƒá odpowied≈∫ do pliku z rozszerzeniem *.zip, u≈ºyj opcji `-o`.
- Aby wykorzystaƒá kodowanie base64 podczas szyfrowania, u≈ºyj opcji `--armor`
- Aby za pomocƒÖ narzƒôdzia cURL wys≈Çaƒá plik do serwera, u≈ºyj sk≈Çadni: `-F "plik=@hello.txt"`

---

## Exercise 5.7

Pod adresem http://127.0.0.1:5007 dzia≈Ça prosty serwer HTTP udostƒôpniajƒÖcy 2 endpointy: http://127.0.0.1:5007/decrypt oraz http://127.0.0.1:5007/submit.

**(a)** Uruchom serwer za pomocƒÖ poni≈ºszego polecenia:

```bash
docker rm -f ex7
docker run -p 5007:5007 --name ex7 docker.io/mazurkatarzyna/gpg-ex7:latest
```

**(b)** Wy≈õlij request do endpointa http://127.0.0.1:5007/decrypt u≈ºywajƒÖc metody HTTP GET i zapisz odpowied≈∫ do pliku z rozszerzeniem *.zip.

```bash
curl -s 127.0.0.1:5007/decrypt -o data.zip
```

**(c)** Rozpakuj pobrane archiwum. W odpowiedzi od serwera otrzyma≈Çe≈õ id sesji (jako session_id), klucz publiczny GPG (public_key.asc), klucz prywatny GPG (private_key.asc), oraz s≈Çowo do odszyfrowania (encrypted_word.asc).

```bash
unzip data.zip
```

Output:
```
Archive:  data.zip
  inflating: public_key.asc          
  inflating: private_key.asc         
  inflating: encrypted_word.asc      
  inflating: session_id.txt
```

**(d)** Odszyfruj odebrane od serwera s≈Çowo (encrypted_word.asc) za pomocƒÖ pobranego klucza prywatnego (private_key.asc).

```bash
gpg --import private_key.asc
```

Output:
```
gpg: key 97C3798999919BED: public key "Decrypt Challenge <decrypt@example.com>" imported
gpg: key 97C3798999919BED: secret key imported
gpg: Total number processed: 1
gpg:               imported: 1
gpg:       secret keys read: 1
gpg:   secret keys imported: 1
```

```bash
gpg --decrypt encrypted_word.asc 2>/dev/null
# hidden
```

**(e)** Wy≈õlij request do endpointa http://127.0.0.1:5007/submit u≈ºywajƒÖc metody HTTP POST i prze≈õlij do serwera id sesji (jako session_id) oraz odszyfrowane s≈Çowo (jako tekst, decrypted_word).

```bash
curl -s http://127.0.0.1:5007/submit -F "session_id=a0157ef2b25fc370da886200d19031c9" -F "decrypted_word=hidden" | jq .
```

Output:
```json
{
  "status": "success",
  "message": "üéâ Gratulacje! Poprawnie odszyfrowa≈Çe≈õ s≈Çowo!",
  "word": "hidden"
}
```

**UWAGI:**
- Aby zapisaƒá odpowied≈∫ do pliku z rozszerzeniem *.zip, u≈ºyj opcji `-o`

---

## Exercise 5.8

Pod adresem http://127.0.0.1:5008 dzia≈Ça prosty serwer HTTP udostƒôpniajƒÖcy 2 endpointy: http://127.0.0.1:5008/sign oraz http://127.0.0.1:5008/submit.

**(a)** Uruchom serwer za pomocƒÖ poni≈ºszego polecenia:

```bash
docker run -p 5008:5008 --name ex8 docker.io/mazurkatarzyna/gpg-ex8:latest
```

**(b)** Wy≈õlij request do endpointa http://127.0.0.1:5008/sign u≈ºywajƒÖc metody HTTP GET i zapisz odpowied≈∫ do pliku z rozszerzeniem *.zip.

```bash
curl -s 127.0.0.1:5008/sign -o data.zip
```

**(c)** Rozpakuj pobrane archiwum. W odpowiedzi od serwera otrzyma≈Çe≈õ id sesji (jako session_id), klucz publiczny GPG (public_key.asc), klucz prywatny GPG (private_key.asc), oraz s≈Çowo do podpisania (w pliku word.txt).

```bash
unzip data.zip
```

**(d)** Podpisz plik (word.txt) za pomocƒÖ pobranego klucza publicznego (public_key.asc), tworzƒÖc plik word.txt.gpg.

```bash
gpg --import private_key.asc
```

Output:
```
gpg: key B7D45CF44D0E6224: public key "Sign Challenge <sign@example.com>" imported
gpg: key B7D45CF44D0E6224: secret key imported
gpg: Total number processed: 1
gpg:               imported: 1
gpg:       secret keys read: 1
gpg:   secret keys imported: 1
```

```bash
gpg --list-keys
# pub   rsa2048 2025-11-18 [SCEAR]
#       AA6C7E94A3337ADCD929AEF3B7D45CF44D0E6224
# uid           [ unknown] Sign Challenge <sign@example.com>

gpg --sign -u AA6C7E94A3337ADCD929AEF3B7D45CF44D0E6224 word.txt
```

Verification:
```bash
gpg --verify word.txt.gpg
# gpg: Signature made wto, 18 lis 2025, 12:25:51 CET
# gpg:                using RSA key AA6C7E94A3337ADCD929AEF3B7D45CF44D0E6224
# gpg: Good signature from "Sign Challenge <sign@example.com>" [unknown]
# gpg: WARNING: This key is not certified with a trusted signature!
# gpg:          There is no indication that the signature belongs to the owner.
# Primary key fingerprint: AA6C 7E94 A333 7ADC D929  AEF3 B7D4 5CF4 4D0E 6224
```

Alternative signing methods:
```bash
# Clear sign
gpg --clear-sign -u AA6C7E94A3337ADCD929AEF3B7D45CF44D0E6224 word.txt
cat word.txt.asc

# Detach sign
gpg --detach-sign -u AA6C7E94A3337ADCD929AEF3B7D45CF44D0E6224 word.txt
cat word.txt.sig

gpg --verify word.txt.sig
# gpg: assuming signed data in 'word.txt'
# gpg: Signature made wto, 18 lis 2025, 12:27:47 CET
# gpg:                using RSA key AA6C7E94A3337ADCD929AEF3B7D45CF44D0E6224
# gpg: Good signature from "Sign Challenge <sign@example.com>" [unknown]
# gpg: WARNING: This key is not certified with a trusted signature!
# gpg:          There is no indication that the signature belongs to the owner.
# Primary key fingerprint: AA6C 7E94 A333 7ADC D929  AEF3 B7D4 5CF4 4D0E 6224
```

Testing signature with modified file:
```bash
# nano word.txt add dot 
gpg --verify word.txt.sig
# gpg: assuming signed data in 'word.txt'
# gpg: Signature made wto, 18 lis 2025, 12:27:47 CET
# gpg:                using RSA key AA6C7E94A3337ADCD929AEF3B7D45CF44D0E6224
# gpg: BAD signature from "Sign Challenge <sign@example.com>" [unknown]
```

**(e)** Wy≈õlij request do endpointa http://127.0.0.1:5008/submit u≈ºywajƒÖc metody HTTP POST i prze≈õlij do serwera id sesji (jako session_id) oraz podpisane s≈Çowo (jako plik, signed_file).

```bash
curl -s 127.0.0.1:5008/submit -F "session_id=$(cat session_id.txt)" -F "signed_file=@word.txt.asc" | jq .
```

Output:
```json
{
  "status": "success",
  "message": "‚úçÔ∏è Gratulacje! Poprawnie podpisa≈Çe≈õ plik!",
  "word": "diana",
  "signer": "Sign Challenge <sign@example.com>",
  "signature_valid": true
}
```

**UWAGI:**
- Aby zapisaƒá odpowied≈∫ do pliku z rozszerzeniem *.zip, u≈ºyj opcji `-o`
- Aby utworzyƒá podpis zintegrowany, u≈ºyj opcji `--sign`
- Aby wskazaƒá klucz, kt√≥rego bƒôdziemy u≈ºywaƒá do podpisywania, sprawd≈∫ opcjƒô `-u`
- Aby za pomocƒÖ narzƒôdzia cURL wys≈Çaƒá plik do serwera, u≈ºyj sk≈Çadni: `-F "plik=@hello.txt"`

---

## Exercise 5.9

Pod adresem http://127.0.0.1:5009 dzia≈Ça prosty serwer HTTP udostƒôpniajƒÖcy 2 endpointy: http://127.0.0.1:5009/detach-sign oraz http://127.0.0.1:5009/submit.

**(a)** Uruchom serwer za pomocƒÖ poni≈ºszego polecenia:

```bash
docker rm -f ex9
docker run -p 5009:5009 --name ex9 docker.io/mazurkatarzyna/gpg-ex9:latest
```

**(b)** Wy≈õlij request do endpointa http://127.0.0.1:5009/detach-sign u≈ºywajƒÖc metody HTTP GET i zapisz odpowied≈∫ do pliku z rozszerzeniem *.zip.

```bash
curl -s 127.0.0.1:5009/detach-sign -o data.zip
```

**(c)** Rozpakuj pobrane archiwum. W odpowiedzi od serwera otrzyma≈Çe≈õ id sesji (jako session_id), klucz publiczny GPG (public_key.asc), klucz prywatny GPG (private_key.asc), oraz s≈Çowo do podpisania (w pliku word.txt).

```bash
unzip data.zip
```

Output:
```
Archive:  data.zip
  inflating: word.txt                
  inflating: public_key.asc          
  inflating: private_key.asc         
  inflating: session_id.txt
```

**(d)** Podpisz plik (word.txt) za pomocƒÖ pobranego klucza publicznego (public_key.asc), tworzƒÖc plik word.txt.sig.

```bash
gpg --import private_key.asc
```

Output:
```
gpg: key AD0B21D7AC60C86D: public key "Detach Sign Challenge <detach@example.com>" imported
gpg: key AD0B21D7AC60C86D: secret key imported
gpg: Total number processed: 1
gpg:               imported: 1
gpg:       secret keys read: 1
gpg:   secret keys imported: 1
```

```bash
gpg --detach-sign -u A8A0D9A39A66BE28C3317F06AD0B21D7AC60C86D word.txt

gpg --verify word.txt.sig
# gpg: assuming signed data in 'word.txt'
# gpg: Signature made Sun 30 Nov 2025 10:03:10 PM CET
# gpg:                using RSA key A8A0D9A39A66BE28C3317F06AD0B21D7AC60C86D
# gpg: Good signature from "Detach Sign Challenge <detach@example.com>" [unknown]
```

**(e)** Wy≈õlij request do endpointa http://127.0.0.1:5009/submit u≈ºywajƒÖc metody HTTP POST i prze≈õlij do serwera id sesji (jako session_id), plik ze s≈Çowem (jako plik, original_file) oraz podpisane s≈Çowo (jako plik, signature_file).

```bash
curl -s 127.0.0.1:5009/submit -F "session_id=$(cat session_id.txt)" -F "original_file=@word.txt" -F "signature_file=@word.txt.sig" | jq .
```

Output:
```json
{
  "status": "success",
  "message": "üìé Gratulacje! Poprawnie utworzy≈Çe≈õ oddzielny podpis!",
  "word": "lara",
  "signer": "Detach Sign Challenge <detach@example.com>",
  "signature_valid": true,
  "signature_type": "detached"
}
```

**UWAGI:**
- Aby zapisaƒá odpowied≈∫ do pliku z rozszerzeniem *.zip, u≈ºyj opcji `-o`
- Aby utworzyƒá oddzielny podpis, u≈ºyj opcji `--detach-sign`
- Aby wskazaƒá klucz, kt√≥rego bƒôdziemy u≈ºywaƒá do podpisywania, sprawd≈∫ opcjƒô `-u`
- Aby za pomocƒÖ narzƒôdzia cURL wys≈Çaƒá plik do serwera, u≈ºyj sk≈Çadni: `-F "plik=@hello.txt"`

---

## Exercise 5.10

Pod adresem http://127.0.0.1:5010 dzia≈Ça prosty serwer HTTP udostƒôpniajƒÖcy 2 endpointy: http://127.0.0.1:5010/clearsign oraz http://127.0.0.1:5010/submit.

**(a)** Uruchom serwer za pomocƒÖ poni≈ºszego polecenia:

```bash
docker rm -f ex10
docker run -p 5010:5010 --name ex10 docker.io/mazurkatarzyna/gpg-ex10:latest
```

**(b)** Wy≈õlij request do endpointa http://127.0.0.1:5010/clearsign u≈ºywajƒÖc metody HTTP GET i zapisz odpowied≈∫ do pliku z rozszerzeniem *.zip.

```bash
curl -s 127.0.0.1:5010/clearsign -o data.zip
```

**(c)** Rozpakuj pobrane archiwum. W odpowiedzi od serwera otrzyma≈Çe≈õ id sesji (jako session_id), klucz publiczny GPG (public_key.asc), klucz prywatny GPG (private_key.asc), oraz s≈Çowo do podpisania (w pliku word.txt).

```bash
unzip data.zip
```

Output:
```
Archive:  data.zip
  inflating: word.txt                
  inflating: public_key.asc          
  inflating: private_key.asc         
  inflating: session_id.txt
```

**(d)** Podpisz plik (word.txt) za pomocƒÖ pobranego klucza publicznego (public_key.asc), tworzƒÖc plik word.txt.asc.

```bash
gpg --import private_key.asc
```

Output:
```
gpg: key 9BE5EEFAF4C09C61: public key "Clearsign Challenge <clearsign@example.com>" imported
gpg: key 9BE5EEFAF4C09C61: secret key imported
gpg: Total number processed: 1
gpg:               imported: 1
gpg:       secret keys read: 1
gpg:   secret keys imported: 1
```

```bash
gpg --clear-sign -u 9BE5EEFAF4C09C61 word.txt

gpg --verify word.txt.asc
# gpg: Signature made Sun 30 Nov 2025 10:05:12 PM CET
# gpg:                using RSA key 9D2905941BF42CC2728F59F69BE5EEFAF4C09C61
# gpg: Good signature from "Clearsign Challenge <clearsign@example.com>" [unknown]
```

**(e)** Wy≈õlij request do endpointa http://127.0.0.1:5010/submit u≈ºywajƒÖc metody HTTP POST i prze≈õlij do serwera id sesji (jako session_id) oraz podpisane s≈Çowo (jako plik, clearsigned_file).

```bash
curl -s 127.0.0.1:5010/submit -F "session_id=$(cat session_id.txt)" -F "clearsigned_file=@word.txt.asc" | jq .
```

Output:
```json
{
  "status": "success",
  "message": "üìù Gratulacje! Poprawnie utworzy≈Çe≈õ clear-signed plik!",
  "word": "cristina",
  "signer": "Clearsign Challenge <clearsign@example.com>",
  "signature_valid": true,
  "signature_type": "clearsign"
}
```

**UWAGI:**
- Aby zapisaƒá odpowied≈∫ do pliku z rozszerzeniem *.zip, u≈ºyj opcji `-o`
- Aby utworzyƒá czytelny podpis, u≈ºyj opcji `--clearsign`
- Aby wskazaƒá klucz, kt√≥rego bƒôdziemy u≈ºywaƒá do podpisywania, sprawd≈∫ opcjƒô `-u`
- Aby za pomocƒÖ narzƒôdzia cURL wys≈Çaƒá plik do serwera, u≈ºyj sk≈Çadni: `-F "plik=@hello.txt"`

---

## Exercise 5.11

Pod adresem http://127.0.0.1:5011 dzia≈Ça prosty serwer HTTP udostƒôpniajƒÖcy 2 endpointy: http://127.0.0.1:5011/sign oraz http://127.0.0.1:5011/verify.

**(a)** Uruchom serwer za pomocƒÖ poni≈ºszego polecenia:

```bash
docker rm -f ex11
docker run -p 5011:5011 --name ex11 docker.io/mazurkatarzyna/gpg-ex11:latest
```

**(b)** Wy≈õlij request do endpointa http://127.0.0.1:5011/sign u≈ºywajƒÖc metody HTTP GET i zapisz odpowied≈∫ do pliku z rozszerzeniem *.zip.

```bash
curl -s 127.0.0.1:5011/sign -o data.zip
```

**(c)** Rozpakuj pobrane archiwum. W odpowiedzi od serwera otrzyma≈Çe≈õ id sesji (jako session_id), klucz publiczny GPG (public_key.asc), oraz podpisane s≈Çowo (w pliku word.txt.gpg).

```bash
unzip data.zip
```

Output:
```
Archive:  data.zip
  inflating: word.txt.gpg            
  inflating: public_key.asc          
  inflating: session_id.txt
```

**(d)** Zweryfikuj podpis (plik word.txt.gpg) za pomocƒÖ pobranego klucza publicznego (public_key.asc). W przypadku, gdy weryfikacja siƒô powiedzie, powiniene≈õ zobaczyƒá adres e-mail osoby, kt√≥ra podpisa≈Ça plik.

```bash
gpg --import public_key.asc
```

Output:
```
gpg: key E544DB09F562E71B: public key "Perkins <PERKINS@mail.com>" imported
gpg: Total number processed: 1
gpg:               imported: 1
```

```bash
gpg --verify word.txt.gpg
# gpg: Signature made Sun 30 Nov 2025 10:06:24 PM CET
# gpg:                using RSA key 887785568925A902123CE65DE544DB09F562E71B
# gpg: Good signature from "Perkins <PERKINS@mail.com>" [unknown]
```

**(e)** Wy≈õlij request do endpointa http://127.0.0.1:5011/verify u≈ºywajƒÖc metody HTTP POST i prze≈õlij do serwera id sesji (jako session_id) oraz adres e-mail podpisujƒÖcego (jako tekst, signer_email).

```bash
curl -s 127.0.0.1:5011/verify -F "session_id=$(cat session_id.txt)" -F "signer_email=PERKINS@mail.com" | jq .
```

Output:
```json
{
  "status": "success",
  "message": "üîç Gratulacje! Poprawnie zweryfikowa≈Çe≈õ podpis i zidentyfikowa≈Çe≈õ podpisujƒÖcego!",
  "signer_email": "PERKINS@mail.com",
  "word": "LLOYD"
}
```

**UWAGI:**
- Aby zapisaƒá odpowied≈∫ do pliku z rozszerzeniem *.zip, u≈ºyj opcji `-o`

---

## Exercise 5.12

Pod adresem http://127.0.0.1:5012 dzia≈Ça prosty serwer HTTP udostƒôpniajƒÖcy 2 endpointy: http://127.0.0.1:5012/detach-sign oraz http://127.0.0.1:5012/verify.

**(a)** Uruchom serwer za pomocƒÖ poni≈ºszego polecenia:

```bash
docker rm -f ex12
docker run -p 5012:5012 --name ex12 docker.io/mazurkatarzyna/gpg-ex12:latest
```

**(b)** Wy≈õlij request do endpointa http://127.0.0.1:5012/sign u≈ºywajƒÖc metody HTTP GET i zapisz odpowied≈∫ do pliku z rozszerzeniem *.zip.

```bash
curl -s 127.0.0.1:5012/detach-sign -o data.zip
```

**(c)** Rozpakuj pobrane archiwum. W odpowiedzi od serwera otrzyma≈Çe≈õ id sesji (jako session_id), klucz publiczny GPG (public_key.asc), wylosowane s≈Çowo (w pliku word.txt) oraz podpisane s≈Çowo (w pliku word.txt.sig).

```bash
unzip data.zip
```

Output:
```
Archive:  data.zip
  inflating: word.txt                
  inflating: word.txt.sig            
  inflating: public_key.asc          
  inflating: session_id.txt
```

**(d)** Zweryfikuj podpis (plik word.txt.sig) za pomocƒÖ pobranego klucza publicznego (public_key.asc). W przypadku, gdy weryfikacja siƒô powiedzie, powiniene≈õ zobaczyƒá adres e-mail osoby, kt√≥ra podpisa≈Ça plik.

```bash
gpg --import public_key.asc
```

Output:
```
gpg: key CABCE8785108BF40: public key "House <HOUSE@example.com>" imported
gpg: Total number processed: 1
gpg:               imported: 1
```

```bash
gpg --verify word.txt.sig
# gpg: assuming signed data in 'word.txt'
# gpg: Signature made Sun 30 Nov 2025 10:07:54 PM CET
# gpg:                using RSA key E73D4A3E90D4C8CA2BFC6791CABCE8785108BF40
# gpg: Good signature from "House <HOUSE@example.com>" [unknown]
```

**(e)** Wy≈õlij request do endpointa http://127.0.0.1:5012/verify u≈ºywajƒÖc metody HTTP POST i prze≈õlij do serwera id sesji (jako session_id) oraz adres e-mail podpisujƒÖcego (jako tekst, signer_email).

```bash
curl -s 127.0.0.1:5012/verify -F "session_id=$(cat session_id.txt)" -F "signer_email=HOUSE@example.com" | jq .
```

Output:
```json
{
  "status": "success",
  "message": "üìé Gratulacje! Poprawnie zweryfikowa≈Çe≈õ oddzielny podpis i zidentyfikowa≈Çe≈õ podpisujƒÖcego!",
  "signer_email": "HOUSE@example.com",
  "word": "ESPINOZA"
}
```

**UWAGI:**
- Aby zapisaƒá odpowied≈∫ do pliku z rozszerzeniem *.zip, u≈ºyj opcji `-o`

---

## Exercise 5.13

Pod adresem http://127.0.0.1:5013 dzia≈Ça prosty serwer HTTP udostƒôpniajƒÖcy 2 endpointy: http://127.0.0.1:5013/detach-sign oraz http://127.0.0.1:5012/verify.

**(a)** Uruchom serwer za pomocƒÖ poni≈ºszego polecenia:

```bash
docker rm -f ex13
docker run -p 5013:5013 --name ex13 docker.io/mazurkatarzyna/gpg-ex13:latest
```

**(b)** Wy≈õlij request do endpointa http://127.0.0.1:5013/clearsign u≈ºywajƒÖc metody HTTP GET i zapisz odpowied≈∫ do pliku z rozszerzeniem *.zip.

```bash
curl -s 127.0.0.1:5013/clearsign -o data.zip
```

**(c)** Rozpakuj pobrane archiwum. W odpowiedzi od serwera otrzyma≈Çe≈õ id sesji (jako session_id), klucz publiczny GPG (public_key.asc) oraz podpisane s≈Çowo (w pliku word.txt.asc).

```bash
unzip data.zip
```

Output:
```
Archive:  data.zip
  inflating: word.txt.asc            
  inflating: public_key.asc          
  inflating: session_id.txt
```

**(d)** Zweryfikuj podpis (plik word.txt.asc) za pomocƒÖ pobranego klucza publicznego (public_key.asc). W przypadku, gdy weryfikacja siƒô powiedzie, powiniene≈õ zobaczyƒá adres e-mail osoby, kt√≥ra podpisa≈Ça plik.

```bash
gpg --import public_key.asc
```

Output:
```
gpg: key B4F6E9DAD3BEDA3A: public key "Sloan <SLOAN@test.com>" imported
gpg: Total number processed: 1
gpg:               imported: 1
```

```bash
gpg --verify word.txt.asc
# gpg: Signature made Sun 30 Nov 2025 10:09:26 PM CET
# gpg:                using RSA key 589DC7B651CFDBE7E4FD08FAB4F6E9DAD3BEDA3A
# gpg: Good signature from "Sloan <SLOAN@test.com>" [unknown]
```

**(e)** Wy≈õlij request do endpointa http://127.0.0.1:5013/verify u≈ºywajƒÖc metody HTTP POST i prze≈õlij do serwera id sesji (jako session_id) oraz adres e-mail podpisujƒÖcego (jako tekst, signer_email).

```bash
curl -s 127.0.0.1:5013/verify -F "session_id=$(cat session_id.txt)" -F "signer_email=SLOAN@test.com" | jq .
```

Output:
```json
{
  "status": "success",
  "message": "üìù Gratulacje! Poprawnie zweryfikowa≈Çe≈õ clear-signed plik i zidentyfikowa≈Çe≈õ podpisujƒÖcego!",
  "signer_email": "SLOAN@test.com",
  "word": "ESTES"
}
```

**UWAGI:**
- Aby zapisaƒá odpowied≈∫ do pliku z rozszerzeniem *.zip, u≈ºyj opcji `-o`

---

## Exercise 5.14

Pod adresem http://127.0.0.1:5014 dzia≈Ça prosty serwer HTTP udostƒôpniajƒÖcy 2 endpointy: http://127.0.0.1:5014/getkey oraz http://127.0.0.1:5014/submit.

**(a)** Uruchom serwer za pomocƒÖ poni≈ºszego polecenia:

```bash
docker rm -f ex14
docker run -p 5014:5014 --name ex14 docker.io/mazurkatarzyna/gpg-ex14:latest
```

**(b)** Wy≈õlij request do endpointa http://127.0.0.1:5014/getkey u≈ºywajƒÖc metody HTTP GET i zapisz odpowied≈∫ do pliku z rozszerzeniem *.zip.

```bash
curl -s 127.0.0.1:5014/getkey -o data.zip
```

**(c)** Rozpakuj pobrane archiwum. W odpowiedzi od serwera otrzyma≈Çe≈õ id sesji (jako session_id) oraz klucz publiczny serwera (server_key.asc).

```bash
unzip data.zip
```

Output:
```
Archive:  data.zip
  inflating: server_key.asc          
  inflating: session_id.txt
```

**(d)** Podpisz klucz publiczny serwera swoim kluczem prywatnym. Wyeksportuj podpisany klucz serwera do pliku signed_key.asc.

```bash
gpg --import server_key.asc
```

Output:
```
gpg: key F6E6042C2D6EA4FC: public key "Alston <ALSTON@example.com>" imported
gpg: Total number processed: 1
gpg:               imported: 1
```

```bash
gpg --quick-sign-key 6D7542D40DA02B692BB79878F6E6042C2D6EA4FC

gpg --armor --export 6D7542D40DA02B692BB79878F6E6042C2D6EA4FC > signed_key.asc
gpg --armor --export A1B2C3D4E5F6G7H8I9J0K1L2M3N4O5P6Q7R8S9T0 > my_pubkey.asc
```

**(e)** Wy≈õlij request do endpointa http://127.0.0.1:5014/submit u≈ºywajƒÖc metody HTTP POST i prze≈õlij do serwera id sesji (jako session_id), sw√≥j klucz publiczny (jako plik, your_pubkey) oraz podpisany swoim kluczem prywatnym klucz publiczny serwera (jako plik, signed_key).

```bash
curl -s 127.0.0.1:5014/submit -F "session_id=$(cat session_id.txt)" -F "your_pubkey=@my_pubkey.asc" -F "signed_key=@signed_key.asc" | jq .
```

Output:
```json
{
  "status": "success",
  "message": "‚úçÔ∏è Gratulacje! Poprawnie podpisa≈Çe≈õ klucz serwera!",
  "server_email": "ALSTON@example.com",
  "signer_info": "sig          9F8E7D6C5B4A3210 2025-11-30  Jan Kowalski <jan.kowalski@example.com>",
  "note": "W≈Ça≈õnie uczestniczy≈Çe≈õ w Web of Trust - sieci zaufania GPG!",
  "signatures_found": 3,
  "signer_email": "jan.kowalski@example.com",
  "signer_key_id": "9F8E7D6C5B4A3210"
}
```
