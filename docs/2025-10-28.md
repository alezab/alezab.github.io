# Laboratorium - Szyfrowanie Asymetryczne

Data: 28 października 2025

## Spis treści

- [Wstęp - Podstawy szyfrowania asymetrycznego](#wstęp---podstawy-szyfrowania-asymetrycznego)
- [Zadanie 3.1 - Upload kluczy RSA](#zadanie-31---upload-kluczy-rsa)
- [Zadanie 3.2 - Upload kluczy EC (Elliptic Curve)](#zadanie-32---upload-kluczy-ec-elliptic-curve)
- [Zadanie 3.3 - Weryfikacja par kluczy RSA](#zadanie-33---weryfikacja-par-kluczy-rsa)
- [Zadanie 3.4 - Generowanie klucza publicznego z prywatnego RSA](#zadanie-34---generowanie-klucza-publicznego-z-prywatnego-rsa)
- [Zadanie 3.5 - Generowanie klucza publicznego z prywatnego EC](#zadanie-35---generowanie-klucza-publicznego-z-prywatnego-ec)
- [Zadanie 3.6 - Szyfrowanie RSA z paddingiem OAEP](#zadanie-36---szyfrowanie-rsa-z-paddingiem-oaep)
- [Zadanie 3.7 - Odszyfrowanie RSA z pliku ZIP](#zadanie-37---odszyfrowanie-rsa-z-pliku-zip)
- [Zadanie 3.8 - Kompleksowe zadanie szyfrowania](#zadanie-38---kompleksowe-zadanie-szyfrowania)
- [Zadanie 3.9 - Podpisywanie cyfrowe z paddingiem PSS](#zadanie-39---podpisywanie-cyfrowe-z-paddingiem-pss)
- [Zadanie 3.10 - Weryfikacja podpisu cyfrowego](#zadanie-310---weryfikacja-podpisu-cyfrowego)

---

## Wstęp - Podstawy szyfrowania asymetrycznego

### Typy szyfrowania

**Szyfrowanie asymetryczne:**
- Używa pary kluczy: publicznego i prywatnego
- Klucz publiczny służy do szyfrowania/weryfikacji
- Klucz prywatny służy do deszyfrowania/podpisywania
- Wolniejsze niż szyfrowanie symetryczne, ale bezpieczniejsze do wymiany kluczy

### Algorytmy

**RSA (Rivest-Shamir-Adleman):**
- Najpopularniejszy algorytm asymetryczny
- Rozmiary kluczy: 1024, 2048, 4096 bitów
- Używany do szyfrowania i podpisów cyfrowych

**EC (Elliptic Curve):**
- Krzywe eliptyczne
- Mniejsze klucze przy podobnym poziomie bezpieczeństwa
- Popularne krzywe: prime256v1, secp384r1

### Padding

**OAEP (Optimal Asymmetric Encryption Padding):**
- Używany przy szyfrowaniu RSA
- Zabezpiecza przed atakami na RSA

**PSS (Probabilistic Signature Scheme):**
- Używany przy podpisach cyfrowych RSA
- Parametry: funkcja skrótu (SHA-256), salt length

### OpenSSL - podstawy

```bash
# Generowanie pary kluczy RSA
openssl genpkey -algorithm RSA -out private.pem -pkeyopt rsa_keygen_bits:2048

# Eksport klucza publicznego
openssl pkey -in private.pem -pubout -out public.pem

# Generowanie kluczy EC
openssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:prime256v1 -out ec_private.pem

# Sprawdzanie rozmiaru klucza
openssl pkey -in private.pem -text -noout | grep "Private-Key"
```

---

## Zadanie 3.1 - Upload kluczy RSA

### Polecenie

Pod adresem `http://127.0.0.1:3001` działa prosty serwer HTTP udostępniający dwa endpointy:
- `http://127.0.0.1:3001/upload/public` - upload klucza publicznego
- `http://127.0.0.1:3001/upload/private` - upload klucza prywatnego

**Zadanie:** Wygeneruj parę kluczy RSA (2048 bitów) i wyślij je na serwer.

### Rozwiązanie

#### (a) Uruchomienie serwera

```bash
docker run -p 3001:3001 --name ex1 docker.io/mazurkatarzyna/asymmetric-enc-ex1:latest
```

#### (b) Wygenerowanie pary kluczy RSA

```bash
openssl genpkey -algorithm RSA -out private_key.pem -pkeyopt rsa_keygen_bits:2048
openssl pkey -in private_key.pem -pubout -out public_key.pem
```

#### (c) Wysłanie kluczy do serwera

```bash
curl -X POST http://127.0.0.1:3001/upload/public \
  -H "Content-Type: multipart/form-data" \
  -F "file=@public_key.pem"

curl -X POST http://127.0.0.1:3001/upload/private \
  -H "Content-Type: multipart/form-data" \
  -F "file=@private_key.pem"
```

**Wyjaśnienie:**
- `-F "file=@..."` - wysyła plik jako multipart/form-data
- `-H` - dodaje nagłówek HTTP

---

## Zadanie 3.2 - Upload kluczy EC (Elliptic Curve)

### Polecenie

Pod adresem `http://127.0.0.1:3002` działa prosty serwer HTTP udostępniający dwa endpointy:
- `http://127.0.0.1:3002/upload/ec/public` - upload klucza publicznego EC
- `http://127.0.0.1:3002/upload/ec/private` - upload klucza prywatnego EC

**Zadanie:** Wygeneruj parę kluczy EC (krzywa prime256v1) i wyślij je na serwer.

### Rozwiązanie

#### (a) Uruchomienie serwera

```bash
docker run -p 3002:3002 --name ex2 docker.io/mazurkatarzyna/asymmetric-enc-ex2:latest
```

#### (b) Wygenerowanie pary kluczy EC

```bash
openssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:prime256v1 > ec_private.pem
openssl pkey -in ec_private.pem -pubout > ec_public.pem
```

**Wyjaśnienie:**
- `prime256v1` - krzywa eliptyczna 256-bitowa (NIST P-256)
- Alternatywy: `secp384r1`, `secp521r1`

#### (c) Wysłanie kluczy do serwera

```bash
curl -s -X POST http://127.0.0.1:3002/upload/ec/private \
  -F "file=@ec_private.pem" | jq .

curl -s -X POST http://127.0.0.1:3002/upload/ec/public \
  -F "file=@ec_public.pem" | jq .
```

---

## Zadanie 3.3 - Weryfikacja par kluczy RSA

### Polecenie

Pod adresem `http://127.0.0.1:3003` działa prosty serwer HTTP udostępniający endpoint:
- `http://127.0.0.1:3003/checkkeys` - weryfikacja pary kluczy

**Zadanie:** Wygeneruj parę kluczy RSA (1024 bity) i wyślij je do weryfikacji w formacie JSON.

### Rozwiązanie

#### (a) Uruchomienie serwera

```bash
docker run -p 3003:3003 --name ex3 docker.io/mazurkatarzyna/asymmetric-enc-ex3:latest
```

#### (b) Wygenerowanie pary kluczy RSA 1024-bitowych

```bash
openssl genpkey -algorithm RSA -out ex3_private.pem -pkeyopt rsa_keygen_bits:1024
openssl pkey -in ex3_private.pem -pubout -out ex3_public.pem
```

#### (c) Wysłanie kluczy jako JSON

```bash
jq -n --rawfile priv ex3_private.pem --rawfile pub ex3_public.pem \
  '{private_key_pem: $priv, public_key_pem: $pub}' | \
  curl -s -X POST http://127.0.0.1:3003/checkkeys \
  -H "Content-Type: application/json" \
  -d @- | jq .
```

```json
{
  "result": "Keys are valid and match!"
}
```

**Wyjaśnienie:**
- `jq -n` - tworzy nowy JSON
- `--rawfile` - wczytuje zawartość pliku jako string
- `-d @-` - czyta dane z stdin

---

## Zadanie 3.4 - Generowanie klucza publicznego z prywatnego RSA

### Polecenie

Pod adresem `http://127.0.0.1:3004` działa prosty serwer HTTP udostępniający endpointy:
- `http://127.0.0.1:3004/getprivkey` - pobieranie klucza prywatnego
- `http://127.0.0.1:3004/submit` - wysyłanie klucza publicznego

**Zadanie:** Pobierz klucz prywatny RSA, wygeneruj z niego klucz publiczny i wyślij go wraz z session ID.

### Rozwiązanie

#### (a) Uruchomienie serwera

```bash
docker run -p 3004:3004 --name ex4 docker.io/mazurkatarzyna/asymmetric-enc-ex4:latest
```

#### (b) Pobranie klucza prywatnego i session ID

```bash
curl -s -v -OJ http://127.0.0.1:3004/getprivkey 

# Wyciąganie X-Session-ID:
curl -s -v -OJ http://127.0.0.1:3004/getprivkey 2>&1 | grep "X-Session-ID"
```

**Przykładowy wynik:**
```
X-Session-ID: 52fe1d2b7e736d45
```

Plik zostanie zapisany jako np. `private_key_52fe1d2b7e736d45.pem`

#### (c) Generowanie klucza publicznego

```bash
openssl pkey -in private_key_52fe1d2b7e736d45.pem -pubout > public_key_52fe1d2b7e736d45.pem

# Sprawdzenie rozmiaru klucza
openssl pkey -in private_key_52fe1d2b7e736d45.pem -text -noout | grep "Private-Key"
openssl rsa -in private_key_52fe1d2b7e736d45.pem -text -noout | grep "Private-Key"
```

#### (d) Wysłanie klucza publicznego

```bash
curl -s -X POST http://127.0.0.1:3004/submit \
  -F "public_key_pem=@public_key_52fe1d2b7e736d45.pem" \
  -F "session_id=52fe1d2b7e736d45" | jq .
```

---

## Zadanie 3.5 - Generowanie klucza publicznego z prywatnego EC

### Polecenie

Pod adresem `http://127.0.0.1:3005` działa prosty serwer HTTP udostępniający endpointy:
- `http://127.0.0.1:3005/getprivkey` - pobieranie klucza prywatnego EC
- `http://127.0.0.1:3005/submit` - wysyłanie klucza publicznego

**Zadanie:** Pobierz klucz prywatny EC, wygeneruj z niego klucz publiczny i wyślij go wraz z session ID.

### Rozwiązanie

#### (a) Uruchomienie serwera

```bash
docker run -p 3005:3005 --name ex5 docker.io/mazurkatarzyna/asymmetric-enc-ex5:latest
```

#### (b) Pobranie klucza prywatnego EC

```bash
curl -s -v -OJ http://127.0.0.1:3005/getprivkey 2>&1 | tee output.txt
grep "X-Session-ID" output.txt
```

**Wynik:**
```
X-Session-ID: 8f8a5595c5b01e5f
```

#### (c) Generowanie klucza publicznego

```bash
openssl pkey -in private_key_8f8a5595c5b01e5f.pem -pubout -out public_key_8f8a5595c5b01e5f.pem

# Sprawdzenie rozmiaru klucza
openssl pkey -in private_key_8f8a5595c5b01e5f.pem -text -noout | grep "Private-Key"
```

**Wynik:**
```
Private-Key: (256 bit)
```

#### (d) Wysłanie klucza publicznego

```bash
curl -s -X POST http://127.0.0.1:3005/submit \
  -F "public_key_file=@public_key_8f8a5595c5b01e5f.pem" \
  -F "session_id=8f8a5595c5b01e5f" | jq .
```

```json
{
  "result": "Keys match!"
}
```

---

## Zadanie 3.6 - Szyfrowanie RSA z paddingiem OAEP

### Polecenie

Pod adresem `http://127.0.0.1:3006` działa prosty serwer HTTP udostępniający endpointy:
- `http://127.0.0.1:3006/encrypt` - pobieranie słowa, klucza publicznego i session ID
- `http://127.0.0.1:3006/submit` - wysyłanie zaszyfrowanego słowa

**Zadanie:** Zaszyfruj otrzymane słowo algorytmem RSA-2048 z paddingiem OAEP.

### Rozwiązanie

#### (a) Uruchomienie serwera

```bash
docker run -p 3006:3006 --name ex6 docker.io/mazurkatarzyna/asymmetric-enc-ex6:latest
```

Lub zapasowy:
```bash
docker run -p 3006:3006 --name ex6 ghcr.io/mazurkatarzynaumcs/asymmetric-enc-ex6:latest
```

#### (b) Pobranie danych z serwera

```bash
curl -s -v -OJ http://127.0.0.1:3006/encrypt 2>&1 | tee output.txt
```

**Wynik:**
```
< X-Session-ID: lEXTv9lbG38
< X-Word: nano666
```

Zostanie zapisany plik: `public_key_lEXTv9lbG38.pem`

#### (c) Zaszyfrowanie słowa

```bash
echo -n "nano666" | openssl pkeyutl -encrypt \
  -inkey public_key_lEXTv9lbG38.pem \
  -pubin \
  -pkeyopt rsa_padding_mode:oaep \
  > data.enc
```

**Wyjaśnienie:**
- `pkeyutl` - narzędzie do operacji na kluczach publicznych
- `-encrypt` - szyfrowanie
- `-pubin` - klucz wejściowy to klucz publiczny
- `-pkeyopt rsa_padding_mode:oaep` - padding OAEP

#### (d) Wysłanie zaszyfrowanego słowa

```bash
curl -s -X POST http://127.0.0.1:3006/submit \
  -F "encrypted_file=@data.enc" \
  -F "session_id=lEXTv9lbG38" | jq .
```

```json
{
  "result": "Correct encryption!"
}
```

---

## Zadanie 3.7 - Odszyfrowanie RSA z pliku ZIP

### Polecenie

Pod adresem `http://127.0.0.1:3007` działa prosty serwer HTTP udostępniający endpointy:
- `http://127.0.0.1:3007/decrypt` - pobieranie pliku ZIP z kluczem i zaszyfrowanym słowem
- `http://127.0.0.1:3007/submit` - wysyłanie odszyfrowanego słowa

**Zadanie:** Pobierz plik ZIP, rozpakuj, odszyfruj słowo algorytmem RSA-4096 z paddingiem OAEP.

### Rozwiązanie

#### (a) Uruchomienie serwera

```bash
docker run -p 3007:3007 --name ex7 docker.io/mazurkatarzyna/asymmetric-enc-ex7:latest
```

#### (b) Pobranie pliku ZIP

```bash
curl -s -v -OJ http://127.0.0.1:3007/decrypt 2>&1 | tee output.txt
grep "X-Session-Id" output.txt
```

**Wynik:**
```
X-Session-Id: 7c0e6d0d82fb1e81
```

#### (c) Rozpakowanie pliku

```bash
unzip encrypted_and_key.zip
```

**Zawartość:**
- `encrypted.txt` - zaszyfrowane słowo zakodowane w base64
- `private_key.pem` - klucz prywatny RSA

#### (d) Odszyfrowanie słowa

```bash
# Dekodowanie z base64
base64 -d encrypted.txt > encrypted.bin

# Odszyfrowanie
openssl pkeyutl -decrypt \
  -inkey private_key.pem \
  -in encrypted.bin \
  -pkeyopt rsa_padding_mode:oaep
```

**Wynik:**
```
beyonce87
```

#### (e) Wysłanie odszyfrowanego słowa

```bash
curl -s -X POST http://127.0.0.1:3007/submit \
  -H "Content-Type: application/json" \
  -d '{"session_id": "7c0e6d0d82fb1e81", "decrypted_word": "beyonce87"}' | jq .
```

```json
{
  "result": "Correct decryption!"
}
```

---

## Zadanie 3.8 - Kompleksowe zadanie szyfrowania

### Polecenie

Pod adresem `http://127.0.0.1:3008` działa prosty serwer HTTP udostępniający endpoint:
- `http://127.0.0.1:3008/decrypt` - weryfikacja szyfrowania

**Zadanie:** Wygeneruj własną parę kluczy RSA (1024 bity), zaszyfruj wybrane słowo i wyślij wszystko na serwer do weryfikacji.

### Rozwiązanie

#### (a) Uruchomienie serwera

```bash
docker run -p 3008:3008 --name ex8 docker.io/mazurkatarzyna/asymmetric-enc-ex8:latest
```

#### (b) Wygenerowanie pary kluczy RSA 1024-bitowych

```bash
openssl genpkey -algorithm RSA -out private_key.pem -pkeyopt rsa_keygen_bits:1024
```

**Uwaga:** Serwer wymaga kluczy 1024-bitowych!

#### (c) Eksport klucza publicznego

```bash
openssl pkey -in private_key.pem -pubout -out public_key.pem
```

#### (d) Wybór i zapisanie słowa

```bash
echo -n "testword123" > plaintext.txt
```

#### (e) Zaszyfrowanie słowa

```bash
openssl pkeyutl -encrypt \
  -inkey public_key.pem \
  -pubin \
  -in plaintext.txt \
  -pkeyopt rsa_padding_mode:oaep \
  -out encrypted.bin
```

#### (f) Kodowanie w base64

```bash
base64 encrypted.bin > ciphertext.txt
```

#### (g) Wysłanie wszystkiego do serwera

```bash
curl -s -X POST http://127.0.0.1:3008/decrypt \
  -F "private_key=@private_key.pem" \
  -F "public_key=@public_key.pem" \
  -F "plaintext=@plaintext.txt" \
  -F "ciphertext=@ciphertext.txt" | jq .
```

```json
{
  "decrypted": "testword123",
  "keys_match": true,
  "plaintext_match": true,
  "result": "ok"
}
```

**Wyjaśnienie:**
Serwer sprawdza:
- Czy klucze są prawidłową parą
- Czy odszyfrowane słowo zgadza się z plaintext
- Czy klucze mają 1024 bity

---

## Zadanie 3.9 - Podpisywanie cyfrowe z paddingiem PSS

### Polecenie

Pod adresem `http://127.0.0.1:3009` działa prosty serwer HTTP udostępniający endpointy:
- `http://127.0.0.1:3009/sign` - pobieranie słowa, klucza prywatnego i session ID
- `http://127.0.0.1:3009/submit` - wysyłanie podpisu

**Zadanie:** Podpisz otrzymane słowo kluczem prywatnym używając algorytmu RSA z paddingiem PSS.

### Rozwiązanie

#### (a) Uruchomienie serwera

```bash
docker run -p 3009:3009 --name ex9 docker.io/mazurkatarzyna/asymmetric-enc-ex9:latest
```

Lub zapasowy:
```bash
docker run -p 3009:3009 --name ex9 ghcr.io/mazurkatarzynaumcs/asymmetric-enc-ex9:latest
```

#### (b) Pobranie danych z serwera

```bash
curl -s -v -OJ http://127.0.0.1:3009/sign
```

**Wynik w nagłówkach:**
```
< X-Session-Id: Bu6ZC94_SulK43N0C3yhPQ
< X-Word: garner07
```

Plik: `private_key.pem`

#### (c) Podpisanie słowa

```bash
echo -n "garner07" | openssl dgst -sha256 \
  -sign private_key.pem \
  -sigopt rsa_padding_mode:pss \
  -sigopt rsa_pss_saltlen:32 | \
  base64 > signature.b64
```

**Wyjaśnienie opcji:**
- `dgst -sha256` - funkcja skrótu SHA-256
- `-sign` - podpisywanie
- `-sigopt rsa_padding_mode:pss` - padding PSS
- `-sigopt rsa_pss_saltlen:32` - długość soli = 32 bajty (długość SHA-256)
- `base64` - kodowanie wyniku

#### (d) Wysłanie podpisu

```bash
curl -s -X POST http://127.0.0.1:3009/submit \
  -F "session_id=Bu6ZC94_SulK43N0C3yhPQ" \
  -F "signature_b64=@signature.b64" | jq .
```

```json
{
  "result": "Correct signature!"
}
```

---

## Zadanie 3.10 - Weryfikacja podpisu cyfrowego

### Polecenie

Pod adresem `http://127.0.0.1:3010` działa prosty serwer HTTP udostępniający endpointy:
- `http://127.0.0.1:3010/verify` - pobieranie klucza publicznego, podpisu i słowa
- `http://127.0.0.1:3010/submit` - wysyłanie wyniku weryfikacji

**Zadanie:** Zweryfikuj podpis lokalnie używając algorytmu RSA-2048 z paddingiem PSS i wyślij wynik weryfikacji.

### Rozwiązanie

#### (a) Uruchomienie serwera

```bash
docker run -p 3010:3010 --name ex10 docker.io/mazurkatarzyna/asymmetric-enc-ex10:latest
```

#### (b) Pobranie danych z serwera

```bash
curl -s -v -OJ http://127.0.0.1:3010/verify 2>&1 | tee output.txt
grep -E "X-Session-Id|X-Word" output.txt
```

**Wynik:**
```
X-Session-Id: nHJ6LiXzpPojMxqG5RTqJg
X-Word: melon
```

Plik ZIP zostanie pobrany i nazwany `challenge.zip`

#### (c) Rozpakowanie pliku

```bash
unzip challenge.zip
```

**Zawartość:**
- `public_key.pem` - klucz publiczny RSA
- `signature.b64` - podpis w formacie base64

#### (d) Lokalna weryfikacja podpisu

```bash
# Zapisanie słowa do pliku
echo -n "melon" > word.txt

# Dekodowanie podpisu z base64
base64 -d signature.b64 > signature.bin

# Weryfikacja podpisu
openssl dgst -sha256 \
  -verify public_key.pem \
  -sigopt rsa_padding_mode:pss \
  -sigopt rsa_pss_saltlen:32 \
  -signature signature.bin \
  word.txt
```

**Wynik:**
```
Verified OK
```

#### (e) Wysłanie wyniku weryfikacji do serwera

```bash
curl -s -X POST http://127.0.0.1:3010/submit \
  -F "word=melon" \
  -F "public_key_pem=@public_key.pem" \
  -F "signature_b64=@signature.b64" \
  -F "user_verified=true" \
  -F "session_id=nHJ6LiXzpPojMxqG5RTqJg" | jq .
```

```json
{
  "result": "Correct! Your verification matches the actual signature."
}
```

**Wyjaśnienie:**
- `user_verified=true` - informujemy serwer, że lokalnie weryfikacja się powiodła
- Serwer sprawdza, czy nasza lokalna weryfikacja jest zgodna z rzeczywistym podpisem

---

## Podsumowanie

### Poznane algorytmy i koncepcje

| Temat | Szczegóły |
|-------|-----------|
| **RSA** | Algorytm asymetryczny, klucze 1024-4096 bitów |
| **EC (Elliptic Curve)** | Krzywe eliptyczne, mniejsze klucze, prime256v1 |
| **OAEP Padding** | Padding dla szyfrowania RSA |
| **PSS Padding** | Padding dla podpisów cyfrowych RSA |
| **Podpisy cyfrowe** | Weryfikacja autentyczności i integralności |

### Operacje na kluczach

```bash
# Generowanie kluczy RSA
openssl genpkey -algorithm RSA -out private.pem -pkeyopt rsa_keygen_bits:2048
openssl pkey -in private.pem -pubout -out public.pem

# Generowanie kluczy EC
openssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:prime256v1 -out ec_private.pem
openssl pkey -in ec_private.pem -pubout -out ec_public.pem

# Sprawdzanie rozmiaru klucza
openssl pkey -in private.pem -text -noout | grep "Private-Key"
```

### Szyfrowanie i deszyfrowanie

```bash
# Szyfrowanie RSA z OAEP
echo -n "text" | openssl pkeyutl -encrypt \
  -inkey public.pem -pubin \
  -pkeyopt rsa_padding_mode:oaep > encrypted.bin

# Deszyfrowanie RSA z OAEP
openssl pkeyutl -decrypt \
  -inkey private.pem \
  -in encrypted.bin \
  -pkeyopt rsa_padding_mode:oaep
```

### Podpisywanie i weryfikacja

```bash
# Podpisywanie z PSS
echo -n "text" | openssl dgst -sha256 \
  -sign private.pem \
  -sigopt rsa_padding_mode:pss \
  -sigopt rsa_pss_saltlen:32 | base64 > signature.b64

# Weryfikacja podpisu
openssl dgst -sha256 \
  -verify public.pem \
  -sigopt rsa_padding_mode:pss \
  -sigopt rsa_pss_saltlen:32 \
  -signature signature.bin \
  file.txt
```

### Różnice między szyfrowaniem symetrycznym a asymetrycznym

| Cecha | Symetryczne | Asymetryczne |
|-------|-------------|--------------|
| **Klucze** | Jeden klucz | Para kluczy (publiczny + prywatny) |
| **Szybkość** | Bardzo szybkie | Wolniejsze |
| **Rozmiar klucza** | 128-256 bitów | 1024-4096 bitów (RSA) |
| **Zastosowanie** | Szyfrowanie dużych danych | Wymiana kluczy, podpisy cyfrowe |
| **Przykłady** | AES, 3DES, CAMELLIA | RSA, EC, DSA |

### Najważniejsze wskazówki

1. **Klucz publiczny** - można udostępniać publicznie, służy do szyfrowania i weryfikacji
2. **Klucz prywatny** - musi być chroniony, służy do deszyfrowania i podpisywania
3. **Padding OAEP** - zawsze używaj przy szyfrowaniu RSA
4. **Padding PSS** - zawsze używaj przy podpisach cyfrowych RSA
5. **Salt length** - dla SHA-256 powinien wynosić 32 bajty
6. **Rozmiar klucza** - minimalne bezpieczne to 2048 bitów dla RSA
7. **Base64** - używaj do przesyłania danych binarnych przez HTTP

### Praktyczne zastosowania

- **Szyfrowanie komunikacji** - SSL/TLS (HTTPS)
- **Podpisy cyfrowe** - weryfikacja autentyczności dokumentów
- **Wymiana kluczy** - bezpieczne przesyłanie kluczy symetrycznych
- **Autoryzacja** - klucze SSH, certyfikaty SSL
- **Blockchain** - kryptowaluty używają kryptografii asymetrycznej
