# Laboratorium - Szyfrowanie Symetryczne

Data: 21 października 2025

## Spis treści

- [Wstęp - Podstawy szyfrowania](#wstęp---podstawy-szyfrowania)
- [Zadanie 2.1 - Szyfrowanie AES-256-ECB](#zadanie-21---szyfrowanie-aes-256-ecb)
- [Zadanie 2.2 - Deszyfrowanie AES-256-ECB](#zadanie-22---deszyfrowanie-aes-256-ecb)
- [Zadanie 2.3 - Szyfrowanie CAMELLIA-128-ECB](#zadanie-23---szyfrowanie-camellia-128-ecb)
- [Zadanie 2.4 - Deszyfrowanie CAMELLIA-128-ECB](#zadanie-24---deszyfrowanie-camellia-128-ecb)
- [Zadanie 2.5 - Szyfrowanie ARIA-192-ECB z własnym kluczem](#zadanie-25---szyfrowanie-aria-192-ecb-z-własnym-kluczem)
- [Zadanie 2.6 - Szyfrowanie AES-128-CBC z kluczem i IV](#zadanie-26---szyfrowanie-aes-128-cbc-z-kluczem-i-iv)
- [Zadanie 2.7 - Deszyfrowanie AES-256-CBC z PBKDF2](#zadanie-27---deszyfrowanie-aes-256-cbc-z-pbkdf2)
- [Zadanie 2.8 - Deszyfrowanie 3DES z PBKDF2](#zadanie-28---deszyfrowanie-3des-z-pbkdf2)
- [Zadanie 2.9 - Deszyfrowanie AES-256-ECB z PBKDF2 i iteracjami](#zadanie-29---deszyfrowanie-aes-256-ecb-z-pbkdf2-i-iteracjami)
- [Zadanie 2.10 - Identyfikacja algorytmu szyfrowania](#zadanie-210---identyfikacja-algorytmu-szyfrowania)
- [Zadanie 2.11 - Szyfrowanie obrazka ARIA-128-CTR](#zadanie-211---szyfrowanie-obrazka-aria-128-ctr)

---

## Wstęp - Podstawy szyfrowania

### Typy szyfrowania

**Szyfrowanie symetryczne:**
- Używa tego samego klucza do szyfrowania (E) i deszyfrowania (D)
- Klucz ma ustalony rozmiar: 128-256 bitów
- Szybsze niż szyfrowanie asymetryczne

### Algorytm AES

**Tryby pracy AES:**
- **ECB** (Electronic Codebook) - wymaga tylko klucza
- **CBC** (Cipher Block Chaining) - wymaga klucza + IV (Initialization Vector)

### Kodowanie Base64

```bash
# echo dodaje znak nowej linii
echo "marek" | base64
# bWFyZWsK

# echo -n NIE dodaje znaku nowej linii  
echo -n "marek" | base64
# bWFyZWs=
```

**Ważne:** 6 znaków + `=` to dopełnienie (padding) w Base64

### OpenSSL - podstawy

```bash
# Lista algorytmów szyfrowania
openssl enc -list

# Generowanie losowego klucza (24 bajty = 192 bity)
openssl rand -hex 24
# 74c49dcb50dbaf64a910a2d2e6c562fef51dd25464453d49
```

### PBKDF2 (Password-Based Key Derivation Function 2)

- Funkcja wyprowadzania klucza z hasła
- Parametr `-iter` określa liczbę iteracji
- Parametr `-nosalt` wyłącza użycie soli

---

## Zadanie 2.1 - Szyfrowanie AES-256-ECB

### Polecenie

Pod adresem `http://127.0.0.1:2001` działa prosty serwer HTTP udostępniający 2 endpointy:
- `http://127.0.0.1:2001/encrypt` - pobieranie słowa i klucza
- `http://127.0.0.1:2001/submit` - wysyłanie zaszyfrowanego słowa

**Zadanie:** Zaszyfruj otrzymane słowo algorytmem AES-256 w trybie ECB i wyślij wynik w formacie base64.

### Rozwiązanie

#### (a) Uruchomienie serwera

```bash
docker run -p 2001:2001 --name ex1 docker.io/mazurkatarzyna/symmetric-enc-ex1:latest
```

#### (b) Pobranie słowa i klucza

```bash
curl -X GET http://127.0.0.1:2001/encrypt | jq .
```

```json
{
  "key_hex": "f46765e959030fefffe7ed7886d245d8818d995902b4cbf0f8c2d2c235b9eb98",
  "session_id": "0110b93de5d06d1a",
  "word": "peyton21"
}
```

#### (c) Zaszyfrowanie słowa

```bash
# Kodowanie do base64
echo -n "peyton21" | base64
# cGV5dG9uMjE=

# Szyfrowanie algorytmem AES-256-ECB
echo -n "peyton21" | openssl enc -e -aes-256-ecb -a \
  -K f46765e959030fefffe7ed7886d245d8818d995902b4cbf0f8c2d2c235b9eb98
# FBRgujapf2Z7FfUxjtgRAQ==
```

**Wyjaśnienie opcji:**
- `-e` - szyfrowanie (encrypt)
- `-aes-256-ecb` - algorytm AES-256 w trybie ECB
- `-a` - kodowanie wyjścia do base64
- `-K` - klucz w formacie hex (wielkie K!)

#### (d) Wysłanie odpowiedzi do serwera

```bash
curl -s -X POST http://127.0.0.1:2001/submit \
  -H "Content-Type: application/json" \
  -d '{"session_id": "0110b93de5d06d1a", "encrypted_b64": "FBRgujapf2Z7FfUxjtgRAQ=="}'
```

```json
{
  "result": "Correct encryption!"
}
```

---

## Zadanie 2.2 - Deszyfrowanie AES-256-ECB

### Polecenie

Pod adresem `http://127.0.0.1:2002` działa prosty serwer HTTP udostępniający 2 endpointy:
- `http://127.0.0.1:2002/decrypt` - pobieranie zaszyfrowanego słowa i klucza
- `http://127.0.0.1:2002/submit` - wysyłanie odszyfrowanego słowa

**Zadanie:** Odszyfruj otrzymane słowo algorytmem AES-256 w trybie ECB i wyślij wynik.

### Rozwiązanie

#### (a) Uruchomienie serwera

```bash
docker run -p 2002:2002 --name ex2 docker.io/mazurkatarzyna/symmetric-enc-ex2:latest
```

#### (b) Pobranie zaszyfrowanego słowa i klucza

```bash
curl -s -X GET http://127.0.0.1:2002/decrypt | jq .
```

```json
{
  "encrypted_b64": "tZEacrf+sI7DvmKbQzNGqQ==",
  "key_hex": "9a0eb251a31415a1a882c6a8c0fe0ca6ec6765317b0c5d2701e3888120682d09",
  "session_id": "931bf9de55925aa1"
}
```

#### (c) Deszyfrowanie słowa

```bash
# Odkodowanie z base64 i odszyfrowanie
echo -n "tZEacrf+sI7DvmKbQzNGqQ==" | base64 -d | \
  openssl enc -d -aes-256-ecb \
  -K 9a0eb251a31415a1a882c6a8c0fe0ca6ec6765317b0c5d2701e3888120682d09
# 2111990
```

**Wyjaśnienie opcji:**
- `-d` - deszyfrowanie (decrypt)
- `base64 -d` - dekodowanie z base64

#### (d) Wysłanie odpowiedzi do serwera

```bash
curl -s -X POST http://127.0.0.1:2002/submit \
  -H "Content-Type: application/json" \
  -d '{"session_id": "931bf9de55925aa1", "decrypted_word": "2111990"}'
```

```json
{
  "result": "Correct decryption!"
}
```

---

## Zadanie 2.3 - Szyfrowanie CAMELLIA-128-ECB

### Polecenie

Pod adresem `http://127.0.0.1:2003` działa prosty serwer HTTP udostępniający 2 endpointy:
- `http://127.0.0.1:2003/encrypt` - pobieranie słowa i klucza
- `http://127.0.0.1:2003/submit` - wysyłanie zaszyfrowanego słowa

**Zadanie:** Zaszyfruj otrzymane słowo algorytmem CAMELLIA-128 w trybie ECB.

### Rozwiązanie

#### (a) Uruchomienie serwera

```bash
docker run -p 2003:2003 --name ex3 docker.io/mazurkatarzyna/symmetric-enc-ex3:latest
```

#### (b) Pobranie słowa i klucza

```bash
curl -s -X GET http://127.0.0.1:2003/encrypt | jq .
```

```json
{
  "key_hex": "5f131a6c48839aa407e2e7ae017a5ca7",
  "session_id": "1ca6436f38171ccc",
  "word": "bluelagoon"
}
```

#### (c) Zaszyfrowanie algorytmem CAMELLIA-128

```bash
echo -n "bluelagoon" | openssl enc -e -camellia-128-ecb -a \
  -K 5f131a6c48839aa407e2e7ae017a5ca7
# kyWtUMnczO1EPbQmFEIosQ==
```

#### (d) Wysłanie odpowiedzi do serwera

```bash
curl -s -X POST http://127.0.0.1:2003/submit \
  -H "Content-Type: application/json" \
  -d '{"session_id": "1ca6436f38171ccc", "encrypted_b64": "kyWtUMnczO1EPbQmFEIosQ=="}'
```

```json
{
  "result": "Correct encryption!"
}
```

---

## Zadanie 2.4 - Deszyfrowanie CAMELLIA-128-ECB

### Polecenie

Pod adresem `http://127.0.0.1:2004` działa prosty serwer HTTP udostępniający 2 endpointy:
- `http://127.0.0.1:2004/decrypt` - pobieranie zaszyfrowanego słowa i klucza
- `http://127.0.0.1:2004/submit` - wysyłanie odszyfrowanego słowa

**Zadanie:** Odszyfruj otrzymane słowo algorytmem CAMELLIA-128 w trybie ECB.

### Rozwiązanie

#### (a) Uruchomienie serwera

```bash
docker run -p 2004:2004 --name ex4 docker.io/mazurkatarzyna/symmetric-enc-ex4:latest
```

#### (b) Pobranie zaszyfrowanego słowa i klucza

```bash
curl -s -X GET http://127.0.0.1:2004/decrypt | jq .
```

```json
{
  "encrypted_b64": "hYvg0v9U5dMi7pvI+2EEXQ==",
  "key_hex": "8ff401f2095c144c5d86fe398a4761f6",
  "session_id": "1594b22616f8dd01"
}
```

#### (c) Deszyfrowanie słowa

```bash
echo -n "hYvg0v9U5dMi7pvI+2EEXQ==" | base64 -d | \
  openssl enc -d -camellia-128-ecb \
  -K 8ff401f2095c144c5d86fe398a4761f6
# 619925
```

#### (d) Wysłanie odpowiedzi do serwera

```bash
curl -s -X POST http://127.0.0.1:2004/submit \
  -H "Content-Type: application/json" \
  -d '{"session_id": "1594b22616f8dd01", "decrypted_word": "619925"}'
```

```json
{
  "result": "Correct decryption!"
}
```

---

## Zadanie 2.5 - Szyfrowanie ARIA-192-ECB z własnym kluczem

### Polecenie

Pod adresem `http://127.0.0.1:2005` działa prosty serwer HTTP udostępniający 2 endpointy:
- `http://127.0.0.1:2005/encrypt` - pobieranie słowa do zaszyfrowania
- `http://127.0.0.1:2005/submit` - wysyłanie zaszyfrowanego słowa wraz z kluczem

**Zadanie:** Wygeneruj własny klucz 192-bitowy, zaszyfruj otrzymane słowo algorytmem ARIA-192 w trybie ECB i wyślij wynik wraz z kluczem.

### Rozwiązanie

#### (a) Uruchomienie serwera

```bash
docker run -p 2005:2005 --name ex5 docker.io/mazurkatarzyna/symmetric-enc-ex5:latest
```

#### (b) Pobranie słowa do zaszyfrowania

```bash
curl -s -X GET http://127.0.0.1:2005/encrypt | jq .
```

```json
{
  "session_id": "4d7ecc517e36decf",
  "word": "posthardcore"
}
```

#### (c) Wygenerowanie klucza 192-bitowego

```bash
# 192 bity = 24 bajty = 48 znaków hex
openssl rand -hex 24
# ae9c2b710854c7fa68d69b326012a11b56b1c81e4758c03b
```

#### (d) Zaszyfrowanie słowa

```bash
echo -n "posthardcore" | openssl enc -e -aria-192-ecb -a \
  -K ae9c2b710854c7fa68d69b326012a11b56b1c81e4758c03b
# brQ7sXIxXfltYwXyufaIDg==
```

#### (e) Wysłanie odpowiedzi do serwera

```bash
curl -s -X POST http://127.0.0.1:2005/submit \
  -H "Content-Type: application/json" \
  -d '{
    "session_id": "4d7ecc517e36decf",
    "encrypted_b64": "brQ7sXIxXfltYwXyufaIDg==",
    "key_hex": "ae9c2b710854c7fa68d69b326012a11b56b1c81e4758c03b"
  }'
```

```json
{
  "result": "Correct encryption!"
}
```

---

## Zadanie 2.6 - Szyfrowanie AES-128-CBC z kluczem i IV

### Polecenie

Pod adresem `http://127.0.0.1:2006` działa prosty serwer HTTP udostępniający 2 endpointy:
- `http://127.0.0.1:2006/encrypt` - pobieranie słowa do zaszyfrowania
- `http://127.0.0.1:2006/submit` - wysyłanie zaszyfrowanego słowa wraz z kluczem i IV

**Zadanie:** Wygeneruj własny klucz 128-bitowy i IV (Initialization Vector) 128-bitowy, zaszyfruj otrzymane słowo algorytmem AES-128 w trybie CBC.

### Rozwiązanie

#### (a) Uruchomienie serwera

```bash
docker run -p 2006:2006 --name ex6 docker.io/mazurkatarzyna/symmetric-enc-ex6:latest
```

#### (b) Pobranie słowa do zaszyfrowania

```bash
curl -s -X GET http://127.0.0.1:2006/encrypt | jq .
```

```json
{
  "session_id": "f31c2a06b9c18736",
  "word": "gboy03"
}
```

#### (c) Wygenerowanie klucza 128-bitowego

```bash
# 128 bitów = 16 bajtów = 32 znaki hex
openssl rand -hex 16
# a7380441512f607f4a7997a8fa9c3ce8
```

#### (d) Wygenerowanie wektora inicjalizującego (IV)

```bash
# IV również musi mieć 128 bitów
openssl rand -hex 16
# e4095539a20b5a14e8d60fa1eb198a30
```

#### (e) Zaszyfrowanie słowa algorytmem AES-128-CBC

```bash
echo -n "gboy03" | openssl enc -e -aes-128-cbc -a \
  -K a7380441512f607f4a7997a8fa9c3ce8 \
  -iv e4095539a20b5a14e8d60fa1eb198a30
# Mm5Gm68uHBTOzFCAcL87qg==
```

**Wyjaśnienie:**
- `-iv` - wektor inicjalizujący (initialization vector)
- Opcja `-a` automatycznie koduje wynik do base64

#### (f) Wysłanie odpowiedzi do serwera

```bash
curl -s -X POST http://127.0.0.1:2006/submit \
  -H "Content-Type: application/json" \
  -d '{
    "session_id": "f31c2a06b9c18736",
    "encrypted_b64": "Mm5Gm68uHBTOzFCAcL87qg==",
    "key_hex": "a7380441512f607f4a7997a8fa9c3ce8",
    "iv_hex": "e4095539a20b5a14e8d60fa1eb198a30"
  }'
```

```json
{
  "result": "Correct encryption!"
}
```

---

## Zadanie 2.7 - Deszyfrowanie AES-256-CBC z PBKDF2

### Polecenie

Pod adresem `http://127.0.0.1:2007` działa prosty serwer HTTP udostępniający 2 endpointy:
- `http://127.0.0.1:2007/decrypt` - pobieranie zaszyfrowanego słowa, hasła i IV
- `http://127.0.0.1:2007/submit` - wysyłanie odszyfrowanego słowa

**Zadanie:** Odszyfruj otrzymane słowo algorytmem AES-256-CBC, gdzie klucz jest wygenerowany z hasła przy użyciu funkcji PBKDF2.

### Rozwiązanie

#### (a) Uruchomienie serwera

```bash
docker run -p 2007:2007 --name ex7 docker.io/mazurkatarzyna/symmetric-enc-ex7:latest
```

#### (b) Pobranie zaszyfrowanego słowa, hasła i IV

```bash
curl -s -X GET http://127.0.0.1:2007/decrypt | jq .
```

```json
{
  "encrypted_b64": "KtkoczPXO7yY8w4bLJqSkvDUgFBZHTlXv/V02hFm/m4=",
  "iv_hex": "848962a1f03b9d2fc850b25621916697",
  "password": "jada411",
  "session_id": "9407502f4a3b3236"
}
```

#### (c) Deszyfrowanie z użyciem PBKDF2

```bash
echo "KtkoczPXO7yY8w4bLJqSkvDUgFBZHTlXv/V02hFm/m4=" | base64 -d | \
  openssl enc -d -aes-256-cbc -pbkdf2 -nosalt \
  -pass pass:jada411 \
  -iv 848962a1f03b9d2fc850b25621916697
# tashale
```

**Wyjaśnienie opcji:**
- `-pbkdf2` - użycie funkcji PBKDF2 do wyprowadzenia klucza z hasła
- `-nosalt` - bez użycia soli (serwer nie użył soli podczas szyfrowania)
- `-pass pass:jada411` - hasło do wygenerowania klucza

#### (d) Wysłanie odpowiedzi do serwera

```bash
curl -s -X POST http://127.0.0.1:2007/submit \
  -H "Content-Type: application/json" \
  -d '{"session_id": "9407502f4a3b3236", "decrypted_word": "tashale"}'
```

```json
{
  "result": "Correct decryption!"
}
```

---

## Zadanie 2.8 - Deszyfrowanie 3DES z PBKDF2

### Polecenie

Pod adresem `http://127.0.0.1:2008` działa prosty serwer HTTP udostępniający 2 endpointy:
- `http://127.0.0.1:2008/decrypt` - pobieranie zaszyfrowanego słowa, hasła i IV
- `http://127.0.0.1:2008/submit` - wysyłanie odszyfrowanego słowa

**Zadanie:** Odszyfruj otrzymane słowo algorytmem 3DES (Triple DES), gdzie klucz jest wygenerowany z hasła przy użyciu funkcji PBKDF2.

### Rozwiązanie

#### (a) Uruchomienie serwera

```bash
docker run -p 2008:2008 --name ex8 docker.io/mazurkatarzyna/symmetric-enc-ex8:latest
```

#### (b) Pobranie zaszyfrowanego słowa, hasła i IV

```bash
curl -s -X GET http://127.0.0.1:2008/decrypt | jq .
```

```json
{
  "encrypted_b64": "6eobLY1Z5CaBqYbJlXOp7jH0X/V3ag4v",
  "iv_hex": "3fb1053dbbe64ab1",
  "password": "liltammy",
  "session_id": "818d77da3a56e766"
}
```

#### (c) Deszyfrowanie algorytmem 3DES

```bash
echo "6eobLY1Z5CaBqYbJlXOp7jH0X/V3ag4v" | base64 -d | \
  openssl enc -d -des-ede3-cbc -pbkdf2 -nosalt \
  -pass pass:liltammy \
  -iv 3fb1053dbbe64ab1
# tehuti
```

**Wyjaśnienie:**
- `-des-ede3-cbc` - algorytm Triple DES w trybie CBC
- Pozostałe opcje jak w zadaniu 2.7

#### (d) Wysłanie odpowiedzi do serwera

```bash
curl -s -X POST http://127.0.0.1:2008/submit \
  -H "Content-Type: application/json" \
  -d '{"session_id": "818d77da3a56e766", "decrypted_word": "tehuti"}'
```

```json
{
  "result": "Correct decryption!"
}
```

---

## Zadanie 2.9 - Deszyfrowanie AES-256-ECB z PBKDF2 i iteracjami

### Polecenie

Pod adresem `http://127.0.0.1:2009` działa prosty serwer HTTP udostępniający 2 endpointy:
- `http://127.0.0.1:2009/decrypt` - pobieranie zaszyfrowanego słowa i hasła
- `http://127.0.0.1:2009/submit` - wysyłanie odszyfrowanego słowa

**Zadanie:** Odszyfruj otrzymane słowo algorytmem AES-256-ECB, gdzie klucz jest wygenerowany z hasła przy użyciu funkcji PBKDF2 z liczbą iteracji równą 356.

### Rozwiązanie

#### (a) Uruchomienie serwera

```bash
docker run -p 2009:2009 --name ex9 docker.io/mazurkatarzyna/symmetric-enc-ex9:latest
```

#### (b) Pobranie zaszyfrowanego słowa i hasła

```bash
curl -s -X GET http://127.0.0.1:2009/decrypt | jq .
```

```json
{
  "encrypted_b64": "akR4MPXY37jCadahU+8PDd60YwSFi1EVj1/xlLuadVE=",
  "password": "mousette",
  "session_id": "5d8ef91059b1fd21"
}
```

#### (c) Deszyfrowanie z określoną liczbą iteracji

```bash
echo "akR4MPXY37jCadahU+8PDd60YwSFi1EVj1/xlLuadVE=" | base64 -d | \
  openssl enc -d -aes-256-ecb -pbkdf2 -iter 356 -nosalt \
  -pass pass:mousette
# wolves300
```

**Wyjaśnienie opcji:**
- `-iter 356` - liczba iteracji PBKDF2 (domyślnie jest to 10000)

#### (d) Wysłanie odpowiedzi do serwera

```bash
curl -s -X POST http://127.0.0.1:2009/submit \
  -H "Content-Type: application/json" \
  -d '{"session_id": "5d8ef91059b1fd21", "decrypted_word": "wolves300"}'
```

```json
{
  "result": "Correct decryption!"
}
```

---

## Zadanie 2.10 - Identyfikacja algorytmu szyfrowania

### Polecenie

Pod adresem `http://127.0.0.1:2010` działa prosty serwer HTTP udostępniający 2 endpointy:
- `http://127.0.0.1:2010/decrypt` - pobieranie zaszyfrowanego słowa, klucza i IV (jeśli potrzebny)
- `http://127.0.0.1:2010/submit` - wysyłanie odszyfrowanego słowa i nazwy algorytmu

**Zadanie:** Odgadnij, jaki algorytm został użyty do zaszyfrowania słowa, a następnie odszyfruj je i wyślij wraz z nazwą algorytmu.

### Rozwiązanie

#### (a) Uruchomienie serwera

```bash
docker run -p 2010:2010 --name ex10 docker.io/mazurkatarzyna/symmetric-enc-ex10:latest
```

#### (b) Pobranie zaszyfrowanego słowa i kluczy

```bash
curl -s -X GET http://127.0.0.1:2010/decrypt | jq .
```

```json
{
  "encrypted_b64": "Oqw1Pw0a97GikC+WgBWPSg==",
  "iv_hex": "d97ea1490bb93d3a213b2c83a168c120",
  "key_hex": "dffd6c3f2259c76bb480afd1a3d8d39b40341612b7bd8d9995c285272d9ad467",
  "session_id": "f979b0cba9f6bb09"
}
```

#### (c) Testowanie różnych algorytmów

```bash
# Test 1: AES-256-CBC
echo "Oqw1Pw0a97GikC+WgBWPSg==" | base64 -d | \
  openssl enc -d -aes-256-cbc \
  -K dffd6c3f2259c76bb480afd1a3d8d39b40341612b7bd8d9995c285272d9ad467 \
  -iv d97ea1490bb93d3a213b2c83a168c120
# bad decrypt - błąd!

# Test 2: AES-256-CFB
echo "Oqw1Pw0a97GikC+WgBWPSg==" | base64 -d | \
  openssl enc -d -aes-256-cfb \
  -K dffd6c3f2259c76bb480afd1a3d8d39b40341612b7bd8d9995c285272d9ad467 \
  -iv d97ea1490bb93d3a213b2c83a168c120
# Daje wynik, ale niepoprawny

# Test 3: AES-256-CTR ✓
echo "Oqw1Pw0a97GikC+WgBWPSg==" | base64 -d | \
  openssl enc -d -aes-256-ctr \
  -K dffd6c3f2259c76bb480afd1a3d8d39b40341612b7bd8d9995c285272d9ad467 \
  -iv d97ea1490bb93d3a213b2c83a168c120
# volusia - POPRAWNY ALGORYTM!
```

**Strategia testowania:**
1. Sprawdź rozmiar klucza (256 bitów = 32 bajty = 64 znaki hex) → AES-256
2. Sprawdź obecność IV → tryb wymaga IV (nie ECB)
3. Testuj różne tryby: CBC, CFB, CTR, OFB itp.

#### (d) Wysłanie odpowiedzi do serwera

```bash
curl -s -X POST http://127.0.0.1:2010/submit \
  -H "Content-Type: application/json" \
  -d '{
    "session_id": "f979b0cba9f6bb09",
    "decrypted_word": "volusia",
    "algorithm": "aes-256-ctr"
  }'
```

```json
{
  "result": "Correct decryption and algorithm!"
}
```

---

## Zadanie 2.11 - Szyfrowanie obrazka ARIA-128-CTR

### Polecenie

Pod adresem `http://127.0.0.1:2011` działa prosty serwer HTTP udostępniający 2 endpointy:
- `http://127.0.0.1:2011/encrypt` - pobieranie obrazka do zaszyfrowania, klucza i IV
- `http://127.0.0.1:2011/submit` - wysyłanie zaszyfrowanego obrazka

**Zadanie:** Zaszyfruj otrzymany obrazek algorytmem ARIA-128-CTR (bez paddingu) i wyślij wynik.

### Rozwiązanie

#### (a) Uruchomienie serwera

```bash
docker run -p 2011:2011 --name ex11 docker.io/mazurkatarzyna/symmetric-enc-ex11:latest
```

#### (b) Pobranie danych z serwera

```bash
curl -s -X GET http://127.0.0.1:2011/encrypt | jq .
```

```json
{
  "algorithm": "ARIA-128-CTR",
  "image_data_base64": "iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAIx0lEQVR4Xu...",
  "iv": "733ccdb7bcbd45fc4b350b03c27b4816",
  "key": "eab8872a6aeb4f127aa5bfe7502e8e75",
  "key_size_bits": 128,
  "session_id": "a221fb5d-e092-4388-9182-ac46e009c7bd"
}
```

#### (c) Dekodowanie obrazka z base64 i szyfrowanie

```bash
# Krok 1: Dekodowanie obrazka z base64
echo "iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAIx0lEQVR4Xu..." | \
  base64 -d > /tmp/image.png

# Krok 2: Szyfrowanie obrazka algorytmem ARIA-128-CTR
openssl enc -e -aria-128-ctr -in /tmp/image.png \
  -K eab8872a6aeb4f127aa5bfe7502e8e75 \
  -iv 733ccdb7bcbd45fc4b350b03c27b4816 | \
  base64 -w 0 > /tmp/encrypted_image.b64
```

**Wyjaśnienie:**
- `-in /tmp/image.png` - plik wejściowy
- `base64 -w 0` - kodowanie do base64 bez zawijania linii
- Tryb CTR nie wymaga paddingu

#### (d) Wysłanie odpowiedzi do serwera

```bash
ENCRYPTED_DATA=$(cat /tmp/encrypted_image.b64)
curl -s -X POST http://127.0.0.1:2011/submit \
  -H "Content-Type: application/json" \
  -d "{\"session_id\": \"a221fb5d-e092-4388-9182-ac46e009c7bd\", \"encrypted_data\": \"$ENCRYPTED_DATA\"}"
```

```json
{
  "details": {
    "algorithm": "ARIA-128-CTR",
    "encrypted_size": 2304,
    "image_file": "studio_microphone.png",
    "key_size": "128 bits"
  },
  "message": "✅ Gratulacje! Prawidłowo zaszyfrowałeś obrazek \"studio_microphone.png\" używając ARIA-128-CTR!",
  "success": true
}
```

---

## Podsumowanie

### Poznane algorytmy szyfrowania

| Algorytm | Rozmiar klucza | Tryby | Uwagi |
|----------|---------------|-------|-------|
| **AES** | 128, 192, 256 bit | ECB, CBC, CTR, CFB | Najbardziej popularny |
| **CAMELLIA** | 128, 192, 256 bit | ECB, CBC, CTR, CFB | Alternatywa dla AES |
| **ARIA** | 128, 192, 256 bit | ECB, CBC, CTR, CFB | Koreański standard |
| **3DES** | 168 bit (efektywnie 112) | CBC, ECB | Przestarzały, używany dla kompatybilności |

### Tryby pracy

- **ECB** (Electronic Codebook) - tylko klucz, nie bezpieczny dla dłuższych danych
- **CBC** (Cipher Block Chaining) - klucz + IV, bezpieczniejszy
- **CTR** (Counter) - klucz + IV, może szyfrować równolegle
- **CFB** (Cipher Feedback) - klucz + IV, szyfrowanie strumienia

### Ważne komendy OpenSSL

```bash
# Szyfrowanie
openssl enc -e -<algorytm> -K <klucz_hex> -iv <iv_hex> -a

# Deszyfrowanie
openssl enc -d -<algorytm> -K <klucz_hex> -iv <iv_hex>

# Z użyciem PBKDF2
openssl enc -d -<algorytm> -pbkdf2 -pass pass:<hasło> -iv <iv_hex>

# Generowanie losowego klucza
openssl rand -hex <liczba_bajtów>
```

### Uwagi końcowe

- Zawsze używaj `echo -n` przy szyfrowaniu tekstów
- Pamiętaj o kolejności: dekodowanie base64 → deszyfrowanie
- Przy szyfrowaniu: szyfrowanie → kodowanie base64
- IV (Initialization Vector) musi być losowy dla każdej operacji
- PBKDF2 służy do bezpiecznego wyprowadzania klucza z hasła
